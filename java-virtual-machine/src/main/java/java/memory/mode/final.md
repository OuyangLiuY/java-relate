与前面介绍的锁和 volatile 相比较，对 final 域的读和写更像是普通的变量访问。对于 final 域，编译器和处理器要遵守两个重排序规则：
1:在构造函数内对一个 final 域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。
2:初次读一个包含 final 域的对象的引用，与随后初次读这个 final 域，这两个操作之间不能重排序。

<1>内存屏障:
屏障类型                         | 指令示例                    | 说明
LoadLoad Barriers               load1; LoadLoad; Load2;     确保Load1数据的装载，之前与Load2及所有后续装载指令的装载
StoreStore Barriers             Store1;StoreStore;Store2;   确保Store1数据对其他处理器可见（刷新到内存），之前于Store2及所有后续存储指令的存储
LoadStore Barriers              Load1; LoadStore; Store2;   确保Load1数据装载，之前于Store2及所有后续的存储指令刷新到内存
StoreLoad Barriers              Store1;StoreLoad;Load2;     确保Store1数据对其他处理器变得可见（指刷新到内存），之前于Load‘及所有后续转载指令的装载。
                                                            该指令会使该屏障之前的所有内存访问指令（存储和装载指令）完成之后，才执行该屏障之后的内存访问指令。
                                                            
示例1：
示例2：如果final域是引用类型
    在构造函数内对一个final引用的对象的成员域的写入，与随后在构造函数外把这个被构造函数对象的引用赋值给一个引用变量，这两个操作之间不能重排！
    
    假设首先线程 A 执行 writerA() 方法，执行完后线程 B 执行 writerB() 方法，执行完后线程 C 执行 readC() 方法。
    1.构造函数执行
    2.写final引用
    3.写final引用对象的成员域
    {StoreStore屏障}
    4.构造函数执行结束
    5.把构造函数的引用赋值给引用变量obj
    6.读对象引用obj
    {LoadLoad屏障}
    7.读final引用的成员域
    
    注意：
    1> 2是对final域的写入，3是对这个final域引用的对象的成员写入，5是把被构造的对象的引用赋值给某个引用变量。故2和3不能重排序，3和5也不能重排序。
    2> JMM可以确保读线程C至少能看到线程A对final引用对象的成员域的写入，即C至少能看到数组下标0的值是1.而写线程B对数组元素的写入，读线程C可能看到，也可能看不到。
        JMM不保证线程B的写入对读线程C可见。因为写线程B和读线程C之间存在竞争，此时的执行结果不可预知。
        
 总结：final 的底层实现？为什么是不可继承不可重写，
    1> final修饰基本数据类型时，必须赋予初始值且不能被改变。
    2> final修饰引用变量时，该应用变量不能再指向其他对象。
    3> final修饰方法时，代表这个方法不可以被子类的方法重写。final方法比非final方法要快，因为在编译的时候已经静态绑定了
    4> final修饰类时，通常该类功能完整，不可以被继承。比如：String,Integer等
       当一个类继承自另外一个类时，那这个类就可以拥有另一个类的域和方法。 所以：被final修饰的类是不能被继承的。因为