## 1、根据对数器找规律

1）某个面试题，输入参数类型简单，并且只有一个实际参数

2）要求的返回值类型也简单，并且只有一个

3）用暴力方法，把输入参数对应的返回值，打印出来看看，进而优化code

### 1.1、题目一：

小虎去买苹果，商店只提供两种类型的塑料袋，每种类型都有任意数量。
1）能装下6个苹果的袋子
2）能装下8个苹果的袋子
小虎可以自由使用两种袋子来装苹果，但是小虎有强迫症，他要求自己使用的袋子数量必须最少，且使用的每个袋子必须装满。
给定一个正整数N，返回至少使用多少袋子。如果N无法让使用的每个袋子必须装满，返回-1

**方法1**：暴力求解

```java
public static int minBags(int apple) {
    if (apple < 0) {
        return -1;
    }
    // 先装8个试试
    int bag8 = apple / 8;
    int rest = apple - bag8 * 8;
    while (bag8 >= 0) {
        if (rest % 6 == 0) {
            return bag8 + rest / 6;
        } else {
            bag8--;
            rest += 8;
        }
    }
    return -1;
}
```

**方法2**：根据上面结果优化之后

```java
public static int minBags2(int apple) {
    if ((apple & 1) != 0) { // 如果是奇数，返回-1
        return -1;
    }
    if (apple < 18) {
        return apple == 0 ? 0 : (apple == 6 || apple == 8) ? 1 : (apple == 12 || apple == 14 || apple == 16) ? 2 : -1;
    }
    return (apple - 18) / 8 + 3;
}
```

### 1.2、题目二：

给定一个正整数N，表示有N份青草统一堆放在仓库里，有一只牛和一只羊，牛先吃，羊后吃，它俩轮流吃草，不管是牛还是羊，每一轮能吃的草量必须是：
1，4，16，64…(4的某次方)
谁最先把草吃完，谁获胜
假设牛和羊都绝顶聪明，都想赢，都会做出理性的决定
根据唯一的参数N，返回谁会赢

方法1：暴力求解

```java
// 如果n份草，最终先手赢，返回"先手"
// 如果n份草，最终后手赢，返回"后手"
public static String whoWin(int n) {
    if (n == 0)
        return "后手";
    if (n <= 5) {
        return n == 2 || n == 5 ? "后手" : "先手";
    }
    int want = 1;
    while (want <= n){
        if(whoWin(n - want).equals("后手")){
            return "先手";
        }
        want *= 4;
    }
    return "后手";
}
```

方法2：根据暴力解得答案优化

```java
// 仔细观察输出结果之后得到如下优化
public static String whoWin2(int n) {
    if(n % 5 == 0 || n % 5 == 2){
        return "后手";
    }else {
        return "先手";
    }
}
```

### 1.3、题目三：

定义一种数：可以表示成若干（数量>1）连续正数和的数
比如:
5 = 2+3，5就是这样的数
12 = 3+4+5，12就是这样的数
1不是这样的数，因为要求数量大于1个、连续正数和
2 = 1 + 1，2也不是，因为等号右边不是连续正数
给定一个参数N，返回是不是可以表示成若干连续正数和的数

方法1：暴力解

```java
public static boolean isMSum1(int num) {
    if (num < 0) {
        return false;
    }
    for (int i = 1; i <= num; i++) {
        int sum = i;
        for (int j = i + 1; j < num; j++) {
            if (j + sum > num) {
                break;
            }
            if (j + sum == num) {
                return true;
            }
            sum += j;
        }
    }
    return false;
}
```

方法2：根据暴力解进行优化

```java
public static boolean isMSum2(int num) {
        return num != (num & (~num + 1));
//        return num != (num & (-num));
//        return (num & (num - 1)) != 0;
    }
```

## 2、根据数据量猜解法

### 2.1 基本常识

1）C/C++，1秒处理的指令条数为10的8次方

2）Java等语言，1~4秒处理的指令条数为10的8次方

3）这里就有大量的空间了！

### 2.2 题目四：

int[] d，d[i]：i号怪兽的能力
int[] p，p[i]：i号怪兽要求的钱
开始时你的能力是0，你的目标是从0号怪兽开始，通过所有的怪兽。
如果你当前的能力，小于i号怪兽的能力，你必须付出p[i]的钱，贿赂这个怪兽，然后怪兽就会加入你，他的能力直接累加到你的能力上；如果你当前的能力，大于等于i号怪兽的能力，你可以选择直接通过，你的能力并不会下降，你也可以选择贿赂这个怪兽，然后怪兽就会加入你，他的能力直接累加到你的能力上。
返回通过所有的怪兽，需要花的最小钱数。

**方法1：根据能力，暴力求解**

```java
//返回是最小钱数
public static long process1(int[] d, int[] p, int ability, int index) {
    // 从0号 开始尝试,直到最后一个位置，
    // 所以base case要定位到最后一个位置上
    if (index == d.length) {
        return 0;
    }
    // 这个怪兽能力大于当前能力,那你要通过，那必须贿赂
    if (ability < d[index]) {
        return p[index] + process1(d, p, d[index] + ability, index + 1);
    } else {
        // 1.贿赂
        long p1 = p[index] + process1(d, p, d[index] + ability, index + 1);
        // 2.不贿赂
        long p2 = process1(d, p, ability, index + 1);
        return Math.min(p1, p2);
    }
}

//返回是最小钱数
public static long minMoney1(int[] d, int[] p) {
    return process1(d, p, 0, 0);
}
```

**方法2：根据付的钱，暴力求解**

```java
//返回是最小钱数
public static int minMoney2(int[] d, int[] p) {
    int allMoney = 0;
    for (int i = 0; i < d.length; i++) {
        allMoney += p[i];
    }
    int N = p.length;
    for (int money = 0; money < allMoney; money++) {
        if (process2(d, p, money, N - 1) != -1) {
            return money;
        }
    }
    return allMoney;
}

// 从0....index号怪兽，花的钱，必须严格==money
// 如果通过不了，返回-1
// 如果可以通过，返回能通过情况下的最大能力值
public static long process2(int[] d, int[] p, int money, int index) {
    if (index < 0) { // 一个怪兽也没遇到呢
        return money == 0 ? 0 : -1;
    }
    // index >= 0
    // 1) 不贿赂当前index号怪兽
    long preMaxAbility = process2(d, p, money, index - 1);
    long p1 = -1;
    if (preMaxAbility != -1 && preMaxAbility >= d[index]) {
        p1 = preMaxAbility;
    }
    // 2) 贿赂当前的怪兽 当前的钱 p[index]
    long preMaxAbility2 = process2(d, p, money - p[index], index - 1);
    long p2 = -1;
    if (preMaxAbility2 != -1) {
        p2 = d[index] + preMaxAbility2;
    }
    return Math.max(p1, p2);
}
```

**方法3：方法1的动态规划**

```java
// minMoney1思路得动态规划
public static long fun1(int[] d, int[] p) {
    int N = d.length;
    int sum = 0;
    for (int num : d) {
        sum += num;
    }
    int[][] dp = new int[N + 1][sum + 1];
    for (int j = 0; j < sum + 1; j++) {
        dp[0][j] = 0;
    }
    for (int i = N - 1; i >= 0; i--) {
        for (int j = 0; j <= sum; j++) {
            // 防止数组列越界
            if (j + d[i] > sum) {
                continue;
            }
            if (j < d[i]) {
                dp[i][j] = p[i] + dp[i + 1][j + d[i]];
            } else {
                dp[i][j] = Math.min(p[i] + dp[i + 1][j + d[i]], dp[i + 1][j]);
            }
        }
    }
    return dp[0][0];
}
```

**方法4：方法2的动态规划**

```java
// minMoney2思路得动态规划
public static long fun2(int[] d, int[] p) {
    int N = d.length;
    int sum = 0;
    for (int num : p) {
        sum += num;
    }
    int[][] dp = new int[N + 1][sum + 1];
    // dp[i][j]含义：
    // 能经过0～i的怪兽，且花钱为j（花钱的严格等于j）时的武力值最大是多少？
    // 如果dp[i][j]==-1，表示经过0～i的怪兽，花钱为j是无法通过的，或者之前的钱怎么组合也得不到正好为j的钱数
    for (int i = 0; i <= N; i++) {
        for (int j = 0; j <= sum; j++) {
            dp[i][j] = -1;
        }
    }
    // 经过0～i的怪兽，花钱数一定为p[0]，达到武力值d[0]的地步。其他第0行的状态一律是无效的
    dp[0][p[0]] = d[0];
    for (int i = 1; i < N; i++) {
        for (int j = 0; j <= sum; j++) {
            // 1) 不贿赂当前index号怪兽
            // 前题是之前得能力大于当前得能力
            if (dp[i - 1][j] >= d[i]) {
                // 两种可能性中，选武力值最大的
                dp[i][j] = dp[i - 1][j];
            }
            // 可能性一，为当前怪兽花钱
            // 存在条件：
            // j - p[i]要不越界，并且在钱数为j - p[i]时，要能通过0～i-1的怪兽，并且钱数组合是有效的。
            // j >= p[i] 防止越界。不然 j + p[i] 就会超过sum
            if (j >= p[i] && dp[i - 1][j - p[i]] != -1) {
                dp[i][j] = Math.max(dp[i][j], d[i] + dp[i - 1][j - p[i]]);
            }
        }
    }
    int ans = sum;
    for (int i = 0; i <= sum; i++) {
        if (dp[N - 1][i] != -1) {
            ans = i;
            break;
        }
    }
    return ans;
}
```