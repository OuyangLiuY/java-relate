## 1、根据对数器找规律

1）某个面试题，输入参数类型简单，并且只有一个实际参数

2）要求的返回值类型也简单，并且只有一个

3）用暴力方法，把输入参数对应的返回值，打印出来看看，进而优化code

### 1.1、题目一：

小虎去买苹果，商店只提供两种类型的塑料袋，每种类型都有任意数量。
1）能装下6个苹果的袋子
2）能装下8个苹果的袋子
小虎可以自由使用两种袋子来装苹果，但是小虎有强迫症，他要求自己使用的袋子数量必须最少，且使用的每个袋子必须装满。
给定一个正整数N，返回至少使用多少袋子。如果N无法让使用的每个袋子必须装满，返回-1

**方法1**：暴力求解

```java
public static int minBags(int apple) {
    if (apple < 0) {
        return -1;
    }
    // 先装8个试试
    int bag8 = apple / 8;
    int rest = apple - bag8 * 8;
    while (bag8 >= 0) {
        if (rest % 6 == 0) {
            return bag8 + rest / 6;
        } else {
            bag8--;
            rest += 8;
        }
    }
    return -1;
}
```

**方法2**：根据上面结果优化之后

```java
public static int minBags2(int apple) {
    if ((apple & 1) != 0) { // 如果是奇数，返回-1
        return -1;
    }
    if (apple < 18) {
        return apple == 0 ? 0 : (apple == 6 || apple == 8) ? 1 : (apple == 12 || apple == 14 || apple == 16) ? 2 : -1;
    }
    return (apple - 18) / 8 + 3;
}
```

### 1.2、题目二：

给定一个正整数N，表示有N份青草统一堆放在仓库里，有一只牛和一只羊，牛先吃，羊后吃，它俩轮流吃草，不管是牛还是羊，每一轮能吃的草量必须是：
1，4，16，64…(4的某次方)
谁最先把草吃完，谁获胜
假设牛和羊都绝顶聪明，都想赢，都会做出理性的决定
根据唯一的参数N，返回谁会赢

方法1：暴力求解

```java
// 如果n份草，最终先手赢，返回"先手"
// 如果n份草，最终后手赢，返回"后手"
public static String whoWin(int n) {
    if (n == 0)
        return "后手";
    if (n <= 5) {
        return n == 2 || n == 5 ? "后手" : "先手";
    }
    int want = 1;
    while (want <= n){
        if(whoWin(n - want).equals("后手")){
            return "先手";
        }
        want *= 4;
    }
    return "后手";
}
```

方法2：根据暴力解得答案优化

```java
// 仔细观察输出结果之后得到如下优化
public static String whoWin2(int n) {
    if(n % 5 == 0 || n % 5 == 2){
        return "后手";
    }else {
        return "先手";
    }
}
```

### 1.3、题目三：

定义一种数：可以表示成若干（数量>1）连续正数和的数
比如:
5 = 2+3，5就是这样的数
12 = 3+4+5，12就是这样的数
1不是这样的数，因为要求数量大于1个、连续正数和
2 = 1 + 1，2也不是，因为等号右边不是连续正数
给定一个参数N，返回是不是可以表示成若干连续正数和的数

方法1：暴力解

```java
public static boolean isMSum1(int num) {
    if (num < 0) {
        return false;
    }
    for (int i = 1; i <= num; i++) {
        int sum = i;
        for (int j = i + 1; j < num; j++) {
            if (j + sum > num) {
                break;
            }
            if (j + sum == num) {
                return true;
            }
            sum += j;
        }
    }
    return false;
}
```

方法2：根据暴力解进行优化

```java
public static boolean isMSum2(int num) {
        return num != (num & (~num + 1));
//        return num != (num & (-num));
//        return (num & (num - 1)) != 0;
    }
```

## 2、根据数据量猜解法

### 2.1 基本常识

1）C/C++，1秒处理的指令条数为10的8次方

2）Java等语言，1~4秒处理的指令条数为10的8次方

3）这里就有大量的空间了！

### 2.2 题目四：

int[] d，d[i]：i号怪兽的能力
int[] p，p[i]：i号怪兽要求的钱
开始时你的能力是0，你的目标是从0号怪兽开始，通过所有的怪兽。
如果你当前的能力，小于i号怪兽的能力，你必须付出p[i]的钱，贿赂这个怪兽，然后怪兽就会加入你，他的能力直接累加到你的能力上；如果你当前的能力，大于等于i号怪兽的能力，你可以选择直接通过，你的能力并不会下降，你也可以选择贿赂这个怪兽，然后怪兽就会加入你，他的能力直接累加到你的能力上。
返回通过所有的怪兽，需要花的最小钱数。

**方法1：根据能力，暴力求解**



**方法2：根据付的钱，暴力求解**



方法3：方法1的动态规划

方法4：方法2的动态规划