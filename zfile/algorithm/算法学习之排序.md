# 开始学习算法

## 异或运算

#### 与：&  

**两个位都为1时，结果才为1**

#### 同或：|

**同或运算：相同以1，不同为0**： （两个位都为0时，结果才为0）

#### 异或：^

**异或运算：相同为0，不同为1**

**解释：** 异或运算就记成**无进位相加**！

列子：

```java
int a = 7; //  => 0111
int b = 13; // => 1101
a ^ b = 12; // => 1010   无进位相加
```

性质：

1. 0 ^ N = N
2. N ^ N = 0
3. a ^ b = b ^ a ; a^b^c^d = b^c^d^a

```
1.
2.
3. a & (-a) =  获取到的是a最右边的一个 1
```

**题目一：**如何不用额外变量交换两个数

```java
// 前提：i 和 j 不能是同一个位置
a[i] = a[i] ^ a[j];
a[j] = a[i] ^ a[j];
a[i] = a[i] ^ a[j];
```

**题目二：** 一个数组中有一个数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这种数

```java
 // arr中，只有一种数，出现奇数次
    public static void printOddTimesNum1(int[] arr) {
        int eor = 0;
        for (int i = 0; i < arr.length; i++) {
            eor ^= arr[i];
        }
        System.out.println(eor);
    }
```

**题目三：**怎么把一个int类型的数，提取出来最右侧的1来

```javascript
// 当前这个数去反 +1   = 当前这个数的负数
int rightOne = n & ((~n) + 1); // 也等于 n & (-n)
```

**题目四：**一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这两种数 

```java
// arr中，有两种数，出现奇数次
    public static void printOddTimesNum2(int[] arr){
        int eor = 0;
        for (int i = 0; i < arr.length; i++) {
            eor ^= arr[i];
        }
        // eor 的值是这个两个奇数 异或值
        //提取出最右的1
        int rightOne = eor & (-eor);
        int arther = 0;
        for (int i = 0; i < arr.length; i++) {
            // arr[1] = 111100011110000
            // rightOne=000000000010000
            if ((arr[i] & rightOne) != 0){
                arther ^= arr[i];
            }
        }
        System.out.println(arther + " " + (eor ^ arther));
    }
```

**题目五：**

一个数组中有一种数出现K次，其他数都出现了M次，
M > 1,  K < M
找到，出现了K次的数，
要求，额外空间复杂度O(1)，时间复杂度O(N)

```java
// 难道比较高,顺便完成了对数器的模式
public static int hashKTimes(int[] arr, int k, int m) {
        Map<Integer, Integer> map = new HashMap<>();
        for (int num : arr) {
            if (map.containsKey(num)) {
                map.put(num, map.get(num) + 1);
            } else {
                map.put(num, 1);
            }
        }
        int ans = 0;
        for (Integer curr : map.keySet()) {
            if (k == map.get(curr)) {
                ans = curr;
                break;
            }
        }
        return ans;
    }

    // 请保证arr中，只有一种数出现了K次，其他数都出现了M次
    public static int onlyKTimes(int[] arr, int k, int m) {
        int[] t = new int[32];
        // t [0] 位置1出现了几个
        for (int value : arr) {
            for (int i = 0; i < 32; i++) {
                // (value >> i & 1) != 0 依次提取位置上为1
                // 表示第 i 位上为1
                if ((value >> i & 1) != 0) {
                    t[i]++;
                }
            }
        }
        // 将所有的arr中的数，依次按照二进制的位数累加到t这个数组中
        int ans = 0;
        for (int i = 0; i < 32; i++) {
            // t[i] % m != 0 说明这个出现k次的数在第i位上有 1
            if (t[i] % m != 0) {
                ans |= (1 << i);
            }
        }
        return ans;
    }

    public static int[] randomArray(int maxKinds, int range, int k, int m) {
        //数组中有多少种类型的数据
        int numKinds = (int) (Math.random() * maxKinds + 2);
        // 至少需要两种数据
        // 数组长度 = ( k + (numKinds-1) * m)
        int[] arr = new int[k + (numKinds - 1) * m];
        int index = 0;
        int kTimesValue = (int) (Math.random() * range) + 1;
        //填充k次数据
        for (; index < k; index++) {
            arr[index] = kTimesValue;
        }
        numKinds--;
        // 填充M次数据
        HashSet<Integer> set = new HashSet<>();
        set.add(kTimesValue);
        while (numKinds > 0) {
            int currNam;
            do {
                currNam = (int) (Math.random() * range + 1);
            } while (set.contains(currNam));
            set.add(currNam);
            numKinds--;
            for (int j = 0; j < m; j++) {
                arr[index++] = currNam;
            }
        }
        //填充m次数据完成
        //arr中数据太过整齐，需要随机打乱
        for (int i = 0; i < arr.length; i++) {
            // 将arr[i] 上的数据随机跟数组上另外一个位置的数据交换
            int a = (int) (Math.random() * arr.length);
            int tmp = arr[i];
            arr[i] = arr[a];
            arr[a] = tmp;
        }
        return arr;
    }

    public static void main(String[] args) {
        int maxKinds = 10;
        int range = 200;
        int testTimes = 10000;
        int max = 9;
        //System.out.println(Arrays.toString(randomArray(maxKinds, range, 2, 3)));
        System.out.println("测试开始...");
        for (int i = 0; i < testTimes; i++) {
            int a = (int) (Math.random() * max + 1);// a 1 ~ 9
            int b = (int) (Math.random() * max + 1);// b 1 ~ 9
            int k = Math.min(a, b);
            int m = Math.max(a, b);
            if (k == m) {
                m++;
            }
            int[] arr = randomArray(maxKinds, range, k, m);
            int res1 = hashKTimes(arr, k, m);
            int res2 = onlyKTimes(arr, k, m);
            if (res1 != res2) {
                System.out.println("出错了....");
                System.out.println("res1 = " + res1);
                System.out.println("res2 = " + res2);
            }
        }
        System.out.println("测试结束...");
    }
```

## 数据结构

### 链表

```java
/**
 * 链表数据结构
 *
 *   单链表
 */
class Node {
    private int value;
    private Node next;

    public Node(int value) {
        this.value = value;
    }
}

/**
 * 双链表
 */
class DoubleNode{
    private int value;
    private DoubleNode last;
    private DoubleNode next;

    public DoubleNode(int value) {
        this.value = value;
    }
}
```

### 单向链表和双向链表的练习：

链表相关的问题几乎都是coding问题

1. 单链表和双链表如何反转
2. 把给定值都删除

```java
/**
 * 链表数据结构
 *
 *   单链表
 */
public class Node {
    public int value;
    public Node next;

    public Node(int value) {
        this.value = value;
    }
}

/**
 * 双链表
 */
class DoubleNode{
    public int value;
    public DoubleNode last;
    public DoubleNode next;

    public DoubleNode(int value) {
        this.value = value;
    }
}

// 反转单链表
    // a -> b -> c -> null
    // c -> b -> a -> null
    public static Node converseNodeList(Node head){

        println(head);
        //head = a
        Node pre = null;
        Node next = null;
        while (head != null){
            //1. 获取head.next给到next节点
            next = head.next;

            //2. 反转之后head.next节点应该指向前置节点pre
            head.next = pre;
            //3. pre节点为当前的head节点
            pre = head;

            //4. 将head 指向 head.next，以此来将整个链表循环
            head = next;
        }
        println(pre);
        return pre;
    }

    // 反转双向链表
    // a -> b -> c -> null
    // c -> b -> a -> null
    public static DoubleNode converseDoubleNodeList(DoubleNode head){
        printlnDoubleNode(head);
        // 反转之后节点对象
        DoubleNode pre = null;
        DoubleNode next = null;
        while (head != null){
            next = head.next;
            head.next = pre;
            head.last = next;
            pre = head;
            head = next;
        }
        printlnDoubleNode(pre);
        return pre;
    }
```



```java
// 把给定值都删除
public static Node removeValue(Node head,int value ){
        //在链表中删除这个值，临界条件，需找到第一个值不为value的节点
        while (head != null){
            if(head.value != value){
                break;
            }
            head = head.next;
        }
        //pre是返回的新的node数据
        Node pre = head;
        Node cur = head;
        while (cur != null){
            if(cur.value == value){
                //改变链表的指向位置
                pre.next = cur.next;
            }else {
                pre = cur;
            }
            cur = cur.next;
        }
        return pre;
    }
```

## 栈和队列

逻辑概念

栈：数据先进后出，犹如弹匣

队列：数据先进先出，好似排队

#### 栈和队列的实际实现

**双向链表实现**

```java
public static class Node<T> {
    public T value;
    public Node<T> last;
    public Node<T> next;

    public Node(T data) {
        value = data;
    }
}
// 中间队列（双端队列）
public static class DoubleEndsQueue<T>{
    public Node<T> head;
    public Node<T> tail;
    // 从头添加数据
    public void  addFromHead(T value){
        Node<T> cur = new Node<>(value);
        if(head == null){
            head = cur;
            tail = cur;
        }else {
            // 从头添加
            cur.next = head;
            head.last = cur;
            // 指针改变
            head = cur;
        }
    }
    // 从尾部添加数据
    public void addFromTail(T value){
        Node<T> cur = new Node<>(value);
        if(tail == null){
            head = cur;
            tail = cur;
        }else {
            // 从尾添加
            cur.last = tail;
            tail.next = cur;
            // 指针改变
            tail = cur;
        }
    }
    // 从头拿取数据
    public T popFromHead(){
        if(head == null){
            return null;
        }
        Node<T> cur = head;
       if(tail == head){
           tail = null;
           head = null;
       }else {
           // 指针改变 head指向下一个节点
           head = head.next;
           //断链只返回这个cur的值，而不是整个head
           cur.next = null;
           head.last = null;
       }
       return cur.value;
    }
    // 从尾部拿取数据
    public T popFromTail(){
        if(tail == null){
            return null;
        }
        Node<T> cur = tail;
        if(tail == head){
            tail = null;
            head = null;
        }else {
            // 指针改变 tail 指向上一个节点
            tail = tail.last;
            //断链只返回这个cur的值，而不是整个head
            cur.last = null;
            head.next = null;
        }
        return cur.value;
    }

    public boolean isEmpty() {
        return head == null;
    }
}
public static class MyStack<T>{
    public DoubleEndsQueue<T> queue;
    public MyStack (){
        this.queue = new DoubleEndsQueue<>();
    }
    public void push(T v){
        // 从头加
        queue.addFromHead(v);
    }
    public T pop(){
        // 从头弹
        return queue.popFromHead();
    }
    public boolean isEmpty() {
        return queue.isEmpty();
    }
}
public static class MyQueue<T>{
    public DoubleEndsQueue<T> queue;
    public MyQueue (){
        this.queue = new DoubleEndsQueue<>();
    }
    public void push(T v){
        queue.addFromHead(v);
    }
    public T pop(){
        return queue.popFromTail();
    }
    public boolean isEmpty(){
        return queue.isEmpty();
    }
}
public static boolean isEqual(Integer o1, Integer o2) {
    if (o1 == null && o2 != null) {
        return false;
    }
    if (o1 != null && o2 == null) {
        return false;
    }
    if (o1 == null && o2 == null) {
        return true;
    }
    return o1.equals(o2);
}
```

**使用数组实现队列：**

```java
// 数组方式实现队列
public static class MyQueue{
        private final int[] arr;
        private int pushI;
        private int popI;
        private int size;
        // 当前数组长度限制
        private  int limit;
        public MyQueue(int limit){
            arr = new int[limit];
            size = 0;
            pushI = 0;
            popI = 0;
        }

        public void push(int v){
            if(size == limit){
                throw new RuntimeException("队列满了，不能在添加数据");
            }
            size ++;
            // 添值
            arr[pushI] = v;
            // beginI 下标加 1
            pushI = nextIndex(pushI);
        }
        public int pop(){
            if(size == 0){
                throw  new RuntimeException("队列空了，不能再获取数据");
            }
            size --;
            int ans = arr[popI] ;
            popI = nextIndex(popI);
            return ans;
        }

        public boolean isEmpty() {
            return size == 0;
        }

        private int nextIndex(int index) {
            return index < limit - 1 ? index + 1 : 0 ;
        }
    }
```





#### 栈和队列的常见面试题

**题1：**怎么用数组实现不超过固定大小的队列和栈？

栈：正常使用

队列：环形数组



**题2：**实现一个特殊的栈，在基本功能的基础上，再实现返回栈中最小元素的功能

1）pop、push、getMin操作的时间复杂度都是 O(1)。 

2）设计的栈类型可以使用现成的栈结构。 

## 递归

**例子：**

求数组arr[L..R]中的最大值，怎么用递归方法实现。

1）将[L..R]范围分成左右两半。左：[L..Mid]  右[Mid+1..R]
2）左部分求最大值，右部分求最大值
3） [L..R]范围上的最大值，是max{左部分最大值，右部分最大值}

注意：2）是个递归过程，当范围上只有一个数，就可以不用再递归了

```java
 // 求arr中的最大值
    public static int getMax(int[] arr) {
        return process(arr, 0, arr.length - 1);
    }
// 一个最简单的递归调用
    public static int process(int[] arr, int L, int R) {
        // base case , arr[L...R] 范围上只有一个数，直接返回，必须要有的
        if (L == R) {
            return arr[L];
        }
        //(L+R) / 2 == L + ((R - L) >> 1)
        int mid = L + ((R - L) >> 1); // 中点   	1
        int letMax = process(arr, L, mid);
        int rightMax = process(arr, mid + 1, R);
        return Math.max(letMax, rightMax);
    }
```

**递归的脑图和实际实现：**

对于新手来说，把调用的过程画出结构图是必须的，这有利于分析递归
递归并不是玄学，递归底层是利用系统栈来实现的
注意：**任何递归函数都一定可以改成非递归**

**Master公式：**

形如
T(N) = a * T(N/b) + O(N^d)(其中的a、b、d都是常数)
的递归函数，可以直接通过Master公式来确定时间复杂度
如果 log(b,a) < d，复杂度为O(N^d)
如果 log(b,a) > d，复杂度为O(N^log(b,a))
如果 log(b,a) == d，复杂度为O(N^d  * logN)

## 哈希表

1. 哈希表在使用层面上可以理解为一种集合结构
2. 如果只有key，没有伴随数据value，可以使用HashSet结构
3. 如果既有key，又有伴随数据value，可以使用HashMap结构
4. 有无伴随数据，是HashMap和HashSet唯一的区别，实际结构是一回事 
5. 使用哈希表增(put)、删(remove)、改(put)和查(get)的操作，可以认为时间复杂度为 O(1)，但是常数时间比较大 
6. 放入哈希表的东西，如果是基础类型，内部按值传递，内存占用是这个东西的大小 
7. 放入哈希表的东西，如果不是基础类型，内部按引用传递，内存占用是8字节

**注意：**

**哈希表在使用时，增删改查时间复杂度都是O(1)**

## 有序表

1. 有序表在使用层面上可以理解为一种集合结构
2. 如果只有key，没有伴随数据value，可以使用TreeSet结构
3. 如果既有key，又有伴随数据value，可以使用TreeMap结构
4. 有无伴随数据，是TreeSet和TreeMap唯一的区别，底层的实际结构是一回事
5. 有序表把key按照顺序组织起来，而哈希表完全不组织
6. 红黑树、AVL树、size-balance-tree和跳表等都属于有序表结构，只是底层具体实现不同
7. 放入如果是基础类型，内部按值传递，内存占用就是这个东西的大小
8. 放入如果不是基础类型，内部按引用传递，内存占用是8字节
9. 不管是什么底层具体实现，只要是有序表，都有以下固定的基本功能和固定的时间复杂度 

**基本API：**

1)void put(K key, V value)
将一个(key，value)记录加入到表中，或者将key的记录 更新成value。

2)V get(K key)
根据给定的key，查询value并返回。

3)void remove(K key)
移除key的记录。 

4)boolean containsKey(K key)
询问是否有关于key的记录。

5)K firstKey()
返回所有键值的排序结果中，最小的那个。

6)K lastKey()
返回所有键值的排序结果中，最大的那个。

7)K floorKey(K key)
返回<= key 离key最近的那个

8)K ceilingKey(K key）
返回>= key 离key最近的那个

**注意：**

1. **Java中有序表是 TreeMap，而TreeMap是用红黑树实现的**
2. **有序表在使用时，比哈希表功能多，时间复杂度都是O(logN)**



## 归并排序

**递归实现**：

1. 整体是递归，左边排好序+右边排好序+merge让整体有序
2. 让其整体有序的过程里用了排外序方法
3. 利用master公式求解时间复杂度

```java
 // 递归实现
    public static void mergeSortOfRecursion(int[] arr) {
        if (arr == null || arr.length < 2) {
            return;
        }
        sort(arr, 0, arr.length - 1);
    }

    private static void sort(int[] arr, int L, int R) {
        // base case 自己写的时候忘记这个临界条件
        if (L == R) {
            return;
        }
        int mid = (L + R) / 2;
        sort(arr, L, mid);
        sort(arr, mid + 1, R);
        merge(arr, mid, L, R);
    }
```



**非递归实现：**

```java
// 归并排序非递归实现
    public static void mergeSortNotRecursion(int[] arr) {
        //
        if (arr == null || arr.length < 2) {
            return;
        }
        int N = arr.length;
        // 步长
        int mergeSize = 1;
        while (mergeSize < N) { // Log N
            // 当前左组的，第一个位置
            int L = 0;
            while (L < N) {
                // 长度不够
                if (mergeSize >= N - L) {
                    break;
                }
                int mid = L + mergeSize - 1;
                int R = mid + Math.min(mergeSize, N - mid - 1);
                merge(arr, mid, L, R);
                L = R + 1;
            }
            // 步长为 2^n
            mergeSize <<= 1;
        }
    }
```

**公共merge方法：**

```java
 private static void merge(int[] arr, int mid, int L, int R) {
        int[] help = new int[R - L + 1];
        int index = 0;
        //左指针（处理左边数据）
        int l = L;
        //右指针（处理右边数据）
        int r = mid + 1;
        //条件:左指针不得大于mid，右指针不得大于R
        while (l <= mid && r <= R) {
            help[index++] = arr[l] <= arr[r] ? arr[l++] : arr[r++];
        }
        // 要么左边数据全部拷贝完毕，只剩右边
        while (r <= R) {
            help[index++] = arr[r++];
        }
        // 要么右边数据全部拷贝完毕，只剩左边
        while (l <= mid) {
            help[index++] = arr[l++];
        }
        //最后将help排好序的数组放进arr中
        System.arraycopy(help, 0, arr, L, help.length);
    }
```

**归并排序复杂度：**

T(N) = 2 * T(N/2) + O(N)

根据master公式可知时间复杂度为O(N * log N)

merge过程需要辅助数组，所以额外空间复杂度为O(N)

**归并排序的实质是把比较行为变为有序信息传递，比O(N ^ 2)要快**

### 题目1：

在一个数组中，一个数左边比它小的数的总和，叫数的小和，所有数的小和累加起来，叫数组小和。求数组小和。
例子： [1,3,4,2,5] 
1左边比1小的数：没有
3左边比3小的数：1
4左边比4小的数：1、3
2左边比2小的数：1
5左边比5小的数：1、3、4、 2		
所以数组的小和为1+1+3+1+1+3+4+2=16 

```java
public static int minSum(int[] arr) {
        if (arr == null || arr.length < 2) {
            return 0;
        }
        return process(arr, 0, arr.length - 1);
    }

    // arr[L..R]既要排好序，也要求小和返回
    // 所有merge时，产生的小和，累加
    // 左 排序   merge
    // 右 排序  merge
    // merge
    private static int process(int[] arr, int L, int R) {
        if (L == R) {
            return 0;
        }
        int mid = (R + L) / 2;
        return process(arr, L, mid) +
                process(arr, mid + 1, R) +
                merge(arr, L, mid, R);
    }

    private static int merge(int[] arr, int L, int M, int R) {
        int[] help = new int[R - L + 1];
        int index = 0;
        int p1 = L;
        int p2 = M + 1;
        int sum = 0;
        while (p1 <= M && p2 <= R) {
            //先求值，再排序
            sum += arr[p1] < arr[p2]? (R- p2 +1) * arr[p1] : 0;
            help[index++] = arr[p1] < arr[p2] ? arr[p1++] : arr[p2++];
        }
        while (p1 <= M){
            help[index ++] = arr[p1++];
        }
        while (p2 <= R){
            help[index ++] = arr[p2++];
        }
        System.arraycopy(help,0,arr,L,help.length);
        return sum;
    }
    public static int minSumForComp(int[]arr){
        if (arr == null || arr.length < 2) {
            return 0;
        }
        int sum = 0;
        for (int i = 0; i < arr.length; i++) {
            for (int j = 0; j < i; j++) {
                sum += arr[j] < arr[i] ? arr[j] : 0;
            }
        }
        return sum;
    }

    public static void main(String[] args) {
        int[] arr1 = {1,3,4,2,5};
        System.out.println(minSum(arr1));
        int[] arr2 = {1,3,4,2,5};
        System.out.println(minSumForComp(arr2));
    }		
```



### 题目2：

在一个数组中，
任何一个前面的数a，和任何一个后面的数b，
如果(a,b)是降序的，就称为逆序对
返回数组中所有的逆序对

```java
public static int reverseNum(int[] arr) {
        return process(arr, 0, arr.length - 1);
    }

    private static int process(int[] arr, int L, int R) {
        if (L == R) {
            return 0;
        }
        int mid = L + ((R - L) >> 1);
        return process(arr, L, mid) + process(arr, mid + 1, R) + merge(arr, L, mid, R);
    }

    private static int merge(int[] arr, int L, int M, int R) {
        int[] help = new int[R - L + 1];
        // 反过来做
        int index = help.length - 1;
        int p1 = M;
        int p2 = R;
        int sum = 0;
        while (p1 >= L && p2 > M) {
            //先求值，再排序,有多少对？ 右边 - mid
            sum += arr[p1] > arr[p2] ? (p2 - M) : 0;
            help[index--] = arr[p1] > arr[p2] ? arr[p1--] : arr[p2--];
        }
        while (p1 >= L) {
            help[index--] = arr[p1--];
        }
        while (p2 > M) {
            help[index--] = arr[p2--];
        }
        System.arraycopy(help, 0, arr, L, help.length);
        return sum;
    }

    public static int comparator(int[] arr) {
        int ans = 0;
        for (int i = 0; i < arr.length; i++) {
            for (int j = i + 1; j < arr.length; j++) {
                if (arr[i] > arr[j]) {
                    ans++;
                }
            }
        }
        return ans;
    }

    public static void main(String[] args) {
        int[] arr1 = {1, 3, 4, 2, 5};
        System.out.println(reverseNum(arr1));
        int[] arr2 = {1, 3, 4, 2, 5};
        System.out.println(comparator(arr2));
    }		
```



### 题目3：

在一个数组中，
对于每个数num，求有多少个后面的数 * 2 依然<num，求总个数
比如：[3,1,7,0,2]
3的后面有：1，0
1的后面有：0
7的后面有：0，2
0的后面没有
2的后面没有
所以总共有5个

### 归并排序补充题目（难）

题目描述：

https://leetcode.com/problems/count-of-range-sum/

给定一个数组arr，两个整数lower和upper，

返回arr中有多少个子数组的累加和在[lower,upper]范围上

**解题思路：**

1. 从0开始，0 ~ i 上前缀和是 s
2. 因为要求从0开始到i上有多少个前缀和再 [lower,upper] 范围上
3. 等同于求从0开始到i上有多少个前缀和落再 [ s-upper, s - lower]
4. 故只需将结果累加到以数组长度为止，则可求得结果

```java
public static int countRangeSum(int[] nums, int lower, int upper) {
		if (nums == null || nums.length == 0) {
			return 0;
		}
		long[] sum = new long[nums.length];
		sum[0] = nums[0];
		for (int i = 1; i < nums.length; i++) {
			sum[i] = sum[i - 1] + nums[i];
		}
		return process(sum, 0, sum.length - 1, lower, upper);
	}

	public static int process(long[] sum, int L, int R, int lower, int upper) {
		if (L == R) {
			return sum[L] >= lower && sum[L] <= upper ? 1 : 0;
		}
		int M = L + ((R - L) >> 1);
		return process(sum, L, M, lower, upper) + process(sum, M + 1, R, lower, upper)
				+ merge(sum, L, M, R, lower, upper);
	}

	public static int merge(long[] arr, int L, int M, int R, int lower, int upper) {
		int ans = 0;
		int windowL = L;
		int windowR = L;
		// [windowL, windowR)
		for (int i = M + 1; i <= R; i++) {
			long min = arr[i] - upper;
			long max = arr[i] - lower;
			while (windowR <= M && arr[windowR] <= max) {
				windowR++;
			}
			while (windowL <= M && arr[windowL] < min) {
				windowL++;
			}
			ans += windowR - windowL;
		}
		long[] help = new long[R - L + 1];
		int i = 0;
		int p1 = L;
		int p2 = M + 1;
		while (p1 <= M && p2 <= R) {
			help[i++] = arr[p1] <= arr[p2] ? arr[p1++] : arr[p2++];
		}
		while (p1 <= M) {
			help[i++] = arr[p1++];
		}
		while (p2 <= R) {
			help[i++] = arr[p2++];
		}
		for (i = 0; i < help.length; i++) {
			arr[L + i] = help[i];
		}
		return ans;
	}
```



## 快速排序

Partition过程：

给定一个数组arr，和一个整数num。请把小于等于num的数放在数组的左边，大于num的数放在数组的右边。
要求额外空间复杂度O(1)，时间复杂度O(N) 

```java
 public static int partition(int[] arr,int L ,int R){
        if(L > R){
            return -1;
        }
        if(L == R){
            return arr[L];
        }
        int lessEqual = L - 1;
        int index = L;
        while (index < R){
            // 以数组中R位置的数比较
            if(arr[index] <= arr[R]){
                swap(arr,index, ++lessEqual);
            }
            index++;
        }
        // 最后将arr[R]这个数据跟arr[L...R-1] 的中点位置的数据替换
        swap(arr,++lessEqual,R);
        return lessEqual;
    }
```



荷兰国旗问题：

给定一个数组arr，和一个整数num。请把小于num的数放在数组的左边，等于num的数放在中间，大于num的数放在数组的右边。
要求额外空间复杂度O(1)，时间复杂度O(N) 

```java
 public static int[] netherLandsFlag(int[] arr,int L, int R){
        if(L>R){
            return new int[] { -1, -1 };
        }
        if(L ==R){
            return new int[]{L,R};
        }
        int less = L -1; // < 区间 右边
        int more = R; // >区间，左边界
        int index = L;
        while (index < more){ // 当前位置，不能和 >区的左边界撞上
            if(arr[index] == arr[R]){
                index++;
            }else if(arr[index] < arr[R]){ // <
//                swap(arr,less + 1, index);
//                less ++;
//                index++; //等同于下面表达式
                swap(arr,++less,index++);
            }else { // >
                swap(arr,index,--more);
            }
        }
        swap(arr,more,R); //最后跟R位置上数据交换
        return new int[]{less+1,more};
    }
```

### 快速排序1.0

在arr[L..R]范围上，进行快速排序的过程：
1）用arr[R]对该范围做partition，<= arr[R]的数在左部分并且保证arr[R]最后来到左部分的最后一个位置，记为M； <= arr[R]的数在右部分（arr[M+1..R]）
2）对arr[L..M-1]进行快速排序(递归)
3）对arr[M+1..R]进行快速排序(递归)
**因为每一次partition都会搞定一个数的位置且不会再变动，所以排序能完成**

```java
   // 快速排序1.0
    public static void quickSort1(int[] arr){
        processor1(arr,0,arr.length - 1);
    }

    private static void processor1(int[] arr, int L, int R) {
        if(L >= R){
            return;
        }
        // 一次排序的结果：
        // L..R partition arr[R] [ <=arr[R] arr[R] >arr[R] ]
        int M = partition(arr,L,R);
        processor1(arr,L , M - 1);
        processor1(arr,M + 1, R);
    }
```

### 快速排序2.0

在arr[L..R]范围上，进行快速排序的过程：
1）用arr[R]对该范围做partition，< arr[R]的数在左部分，== arr[R]的数中间，>arr[R]的数在右部分。假设== arr[R]的数所在范围是[a,b]
2）对arr[L..a-1]进行快速排序(递归)
3）对arr[b+1..R]进行快速排序(递归)
**因为每一次partition都会搞定一批数的位置且不会再变动，所以排序能完成**

```
// 快速排序2.0
public static void quickSort2(int[] arr){
    processor2(arr,0,arr.length - 1);
}

private static void processor2(int[] arr, int L, int R) {
    if(L >= R){
        return;
    }
    // 一次排序的结果：
    // L..R partition arr[R] [ <=arr[R] arr[R] >arr[R] ]
    // **因为每一次partition都会搞定一批数的位置且不会再变动，所以排序能完成**
    int[] M  = netherLandsFlag2(arr,L,R);
    processor2(arr,L , M[0] - 1);
    processor2(arr,M[1] + 1, R);
}
```

**快速排序1.0和2.0的时间复杂度分析**

数组已经有序的时候就是复杂度最高的时候

时间复杂度O(N^2)

### 快速排序3.0(随机快排+荷兰国旗技巧优化)

在arr[L..R]范围上，进行快速排序的过程：
1）在这个范围上，随机选一个数记为num，
1）用num对该范围做partition，< num的数在左部分，== num的数中间，>num的数在右部分。假设== num的数所在范围是[a,b]
2）对arr[L..a-1]进行快速排序(递归)
3）对arr[b+1..R]进行快速排序(递归)
因为每一次partition都会搞定一批数的位置且不会再变动，所以排序能完成

```java
// 快速排序3.0
public static void quickSort3(int[] arr) {
    if (arr == null || arr.length < 2) {
        return;
    }
    processor3(arr, 0, arr.length - 1);
}

private static void processor3(int[] arr, int L, int R) {
    if (L >= R) {
        return;
    }
    // 随机快排序
    swap(arr, L + (int) (Math.random() * (R - L + 1)), R);
    int[] M = netherLandsFlag2(arr, L, R);
    processor3(arr, L, M[0] - 1);
    processor3(arr, M[1] + 1, R);
}
```

**随机快排的时间复杂度分析：**

1）通过分析知道，划分值越靠近中间，性能越好；越靠近两边，性能越差
2）随机选一个数进行划分的目的就是让好情况和差情况都变成概率事件
3）把每一种情况都列出来，会有每种情况下的时间复杂度，但概率都是1/N
4）那么所有情况都考虑，时间复杂度就是这种概率模型下的长期期望！

**时间复杂度O(N*logN)，额外空间复杂度O(logN)都是这么来的。**

## 随机快排的实现

### 递归实现：

```java
public static int[] netherLandsFlag(int[] arr, int L, int R) {
        if (L == R) {
            return new int[]{L, R};
        }
        int index = L;
        int more = R;
        int less = L - 1;
        while (index < more) { // 左边界和右边界不能碰上
            if (arr[index] < arr[R]) {
                SortUtils.swap(arr, index++, ++less);
            } else if (arr[index] > arr[R]) {
                // 大于的时候，index不动，下次继续判断index位置的值
                SortUtils.swap(arr, index, --more);
            } else {
                index++;
            }
        }
        SortUtils.swap(arr, more, R);
        return new int[]{less + 1, more};
    }

    public static void processor(int[] arr, int L, int R) {
        if (L >= R) { // base case 递归结束的条件
            return;
        }
        //为了让R这个位置的值尽量是L...R上的中间值
        SortUtils.swap(arr, L + (int) (Math.random() * ((R - L) + 1)), R);
        int[] res = netherLandsFlag(arr, L, R);
        processor(arr, L, res[0] - 1);
        processor(arr, res[1] + 1, R);
    }

    public static void quickSortRecursive(int[] arr) {
        if (arr == null || arr.length < 2) {
            return;
        }
        processor(arr, 0, arr.length - 1);
    }
```

### 非递归实现：

实现的原理：**其实质也是用了递归的思想，只是将递归产生的stack自己手动使用Oop对象存储起来**

```java
private static void quickSortNonRecursive(int[] arr) {
    if (arr == null || arr.length < 2) {
        return;
    }
    int R = arr.length - 1;
    SortUtils.swap(arr, (int) (Math.random() * (R + 1)), R); // 这就是随机的意思
    int[] equalArea = netherLandsFlag(arr, 0, R);
    int el = equalArea[0];
    int er = equalArea[1];
    Stack<Oop> stack = new Stack<>();
    stack.push(new Oop(0, el - 1));
    stack.push(new Oop(er + 1, R));
    while (!stack.isEmpty()) {
        Oop op = stack.pop(); // op.l ... op.r
        if (op.l < op.r) {
            SortUtils.swap(arr, op.l + (int) (Math.random() * (op.r - op.l + 1)), op.r); // 这就是随机的意思
            int[] innerArea = netherLandsFlag(arr, op.l, op.r);
            int iel = innerArea[0];
            int ier = innerArea[1];
            stack.push(new Oop(op.l, iel - 1));
            stack.push(new Oop(ier + 1, op.r));
        }
    }
}

// 快排非递归版本需要的辅助类
// 要处理的是什么范围上的排序
public static class Oop {
    public int l;
    public int r;

    public Oop(int left, int right) {
        l = left;
        r = right;
    }
}
```

## 堆、堆排序、加强堆

### 比较器：

1)比较器的实质就是重载比较运算符

2)比较器可以很好的应用在特殊标准的排序上 

3)比较器可以很好的应用在根据特殊标准排序的结构上

4)写代码变得异常容易，还用于范型编程 

**任何比较器的统一约定：**

即如下方法：
@Override
public int compare(T o1, T o2) ;

返回负数的情况，就是o1比o2优先的情况

返回正数的情况， 就是o2比o1优先的情况

返回0的情况，就是o1与o2同样优先的情况

### 堆结构：

1. 堆结构就是用数组实现的完全二叉树结构
2. 完全二叉树中如果每棵子树的最大值都在顶部就是大根堆
3. 完全二叉树中如果每棵子树的最小值都在顶部就是小根堆
4. 堆结构的heapInsert与heapify操作
5. 堆结构的增大和减少 
6. 优先级队列结构，就是堆结构 

### 什么是完全二叉树？

树结构中，叶子节点，从左往右依次变满得过程就是完成二叉树。

### 使用数组实现堆结构：

1. 数组从左往右，依次走得过程，可以想象成是一个完全二叉树
2. 数组任意位置idx，它的
3. 左孩子节点：2*idx+1
4. 右孩子节点：2*idx+2
5. 父亲节点：idx-1/2

### 大根堆：

一个树中，从任意一个头节点开始，这个数据的头节点就是这个树的最大值 

### 小根堆：

一个树中，从任意一个头节点开始，这个数据的头节点就是这个树的最小值 

### 语言提供的堆结构 vs 手写的堆结构

**取决于，你有没有动态改信息的需求！**

语言提供的堆结构，如果你动态改数据，不保证依然有序

手写堆结构，因为增加了对象的位置表，所以能够满足动态改信息的需求

### 堆排序

1. 整个数组都变成大根堆结构，建立堆的过程: 
   1. 从上到下的方法，时间复杂度为O(N * LogN)
   2. 从下到上的方法，时间复杂度为O(N)
   
2. 把堆的最大值和堆尾巴的值交换，然后减少堆的大小之后，再去调整堆，一直周而复始，时间复杂度为O(N * Log N)

3. 堆的大小减成0之后，排序完成

   ```java
   // 堆排序额外空间复杂度O(1)
   	public static void heapSort(int[] arr) {
   		if (arr == null || arr.length < 2) {
   			return;
   		}
   		// O(N*logN)
   //		for (int i = 0; i < arr.length; i++) { // O(N)
   //			heapInsert(arr, i); // O(logN)
   //		}
   		// O(N)
   		for (int i = arr.length - 1; i >= 0; i--) {
   			heapify(arr, i, arr.length);
   		}
   		int heapSize = arr.length;
   		swap(arr, 0, --heapSize);
   		// O(N*logN)
   		while (heapSize > 0) { // O(N)
   			heapify(arr, 0, heapSize); // O(logN)
   			swap(arr, 0, --heapSize); // O(1)
   		}
   	}
   
    private static void heapify(int[] arr, int index, int heapSize) {
           int left = index * 2 + 1;
           while (left < heapSize) {
               int largest = left + 1 < heapSize && arr[left + 1] > arr[left] ? left + 1 : left;
               largest = arr[largest] > arr[index] ? largest : index;
               if (largest == index) {
                   break;
               }
               SortUtils.swap(arr, index, largest);
               index = largest;
               left = index * 2 + 1;
           }
       }
   ```

   

### 与堆有关的题目

已知一个几乎有序的数组。几乎有序是指，如果把数组排好顺序的话，每个元素移动的距离一定不超过k，并且k相对于数组长度来说是比较小的。

请选择一个合适的排序策略，对这个数组进行排序。 

```java
public static void sortedArrDistanceLessK(int[] arr,int k){
    if (k == 0) {
        return;
    }
    // 默认小根堆
    PriorityQueue<Integer> heap = new PriorityQueue<>();
    int index = 0;
    // 0...K-1
    for (; index <= Math.min(arr.length - 1, k - 1); index++) {
        heap.add(arr[index]);
    }
    // 將heap堆的值依次彈出，並將還沒有添加到的數據放入到heap堆中，
    int i = 0;
    for (; index < arr.length; i++, index++) {
        heap.add(arr[index]);
        arr[i] = heap.poll();
    }
    // 最後將heap中的最後一組數據依次彈出，則可排序完成
    while (!heap.isEmpty()) {
        arr[i++] = heap.poll();
    }
}
```

### 堆和加强堆

#### 最大线段重合问题（用堆的实现）

给定很多线段，每个线段都有两个数[start, end]，
表示线段开始位置和结束位置，左右都是闭区间
规定：
1）线段的开始和结束位置一定都是整数值
2）线段重合区域的长度必须>=1
返回线段最多重合区域中，包含了几条线段

```java
public static int maxCover2(int[][] lines){
    Line[] ls = new Line[lines.length];
    for (int i = 0; i < lines.length; i++) {
        ls[i] = new Line(lines[i][0],lines[i][1]);
    }
    int max = 0;
    Arrays.sort(ls,(o1,o2) -> o1.start - o2.start);
    // 小根堆，每一条线段的结尾数值，使用默认的
    PriorityQueue<Integer> heap = new PriorityQueue<>();
    for (Line l : ls) {
        // lines[i] -> cur  在黑盒中，把<=cur.start 东西都弹出
        if (!heap.isEmpty() && l.start >= heap.peek()) {
            heap.poll();
        }
        heap.add(l.end);
        max = Math.max(heap.size(), max);
    }
    return max;
}
 public static class Line{
        public int start;
        public int end;

        public Line(int start, int end) {
            this.start = start;
            this.end = end;
        }
    }
```

#### 手動改寫堆

1）建立反向索引表
2）建立比较器
3）核心在于各种结构相互配合，非常容易出错



#### 手动改写堆题目练习

给定一个整型数组，int[] arr；和一个布尔类型数组，boolean[] op
两个数组一定等长，假设长度为N，arr[i]表示客户编号，op[i]表示客户操作
arr = [ 3   ,   3   ,   1   ,  2,      1,      2,      5…
op = [ T   ,   T,      T,     T,      F,      T,       F…
依次表示：3用户购买了一件商品，3用户购买了一件商品，1用户购买了一件商品，2用户购买了一件商品，1用户退货了一件商品，2用户购买了一件商品，5用户退货了一件商品…

```txt
一对arr[i]和op[i]就代表一个事件：
用户号为arr[i]，op[i] == T就代表这个用户购买了一件商品
op[i] == F就代表这个用户退货了一件商品
现在你作为电商平台负责人，你想在每一个事件到来的时候，
都给购买次数最多的前K名用户颁奖。
所以每个事件发生后，你都需要一个得奖名单（得奖区）。
```

**得奖系统的规则：**
1，如果某个用户购买商品数为0，但是又发生了退货事件，则认为该事件无效，得奖名单和上一个事件发生后一致，例子中的5用户
2，某用户发生购买商品事件，购买商品数+1，发生退货事件，购买商品数-1
3，每次都是最多K个用户得奖，K也为传入的参数，如果根据全部规则，得奖人数确实不够K个，那就以不够的情况输出结果

4，得奖系统分为得奖区和候选区，任何用户只要购买数>0，一定在这两个区域中的一个
5，购买数最大的前K名用户进入得奖区，
      在最初时如果得奖区没有到达K个用户，那么新来的用户直接进入得奖区
6，如果购买数不足以进入得奖区的用户，进入候选区

7，如果候选区购买数最多的用户，已经足以进入得奖区，
     该用户就会替换得奖区中购买数最少的用户（大于才能替换），
     如果得奖区中购买数最少的用户有多个，就替换最早进入得奖区的用户
     如果候选区中购买数最多的用户有多个，机会会给最早进入候选区的用户

8，候选区和得奖区是两套时间，
     因用户只会在其中一个区域，所以只会有一个区域的时间，另一个没有
     从得奖区出来进入候选区的用户，得奖区时间删除，
     进入候选区的时间就是当前事件的时间（可以理解为arr[i]和op[i]中的i）
     从候选区出来进入得奖区的用户，候选区时间删除，
     进入得奖区的时间就是当前事件的时间（可以理解为arr[i]和op[i]中的i）

9，如果某用户购买数==0，不管在哪个区域都离开，区域时间删除，
     离开是指彻底离开，哪个区域也不会找到该用户
     如果下次该用户又发生购买行为，产生>0的购买数，
     会再次根据之前规则回到某个区域中，进入区域的时间重记

## 前缀树（prefix tree   trie）

1）单个字符串中，字符从前到后的加到一棵多叉树上
2）字符放在路上，节点上有专属的数据项（常见的是pass和end值）
3）所有样本都这样添加，如果没有路就新建，如有路就复用
4）沿途节点的pass值增加1，每个字符串结束时来到的节点end值增加1

**例子：**

设计一种结构。用户可以：
1）void insert(String str)            添加某个字符串，可以重复添加，每次算1个
2）int search(String str)             查询某个字符串在结构中还有几个
3)  void delete(String str)           删掉某个字符串，可以重复删除，每次算1个
4）int prefixNumber(String str)  查询有多少个字符串，是以str做前缀的

前缀树路的实现方式:

1）固定数组实现

```java
/**
     * 使用数组实现
     */
    public static class Node1 {
        public int pass;
        public int end;
        public Node1[] nexts;

        public Node1() {
            pass = 0;
            end = 0;
            // 这里只考虑26个小写字母
            nexts = new Node1[26];
        }

    }

    public static class Trie1 {
        public Node1 root;

        public Trie1() {
            root = new Node1();
        }

        // 添加某个字符串，可以重复添加，每次算1个
        public void insert(String word) {
            if (word == null) {
                return;
            }
            Node1 node = root;
            node.pass++;
            char[] chars = word.toCharArray();
            int index = 0;
            // 从左往右遍历 a , b , c
            for (int i = 0; i < chars.length; i++) {
                index = chars[i] - 'a';
                // 路径不存在，则新建
                if (node.nexts[index] == null) {
                    node.nexts[index] = new Node1();
                }
                // 拿到下个节点node，并指向当前node
                node = node.nexts[index];
                node.pass++;
            }
            node.end++;
        }

        // 查询某个字符串在结构中还有几个
        public int search(String word) {
            if (word == null) {
                return 0;
            }
            Node1 node = root;
            char[] chars = word.toCharArray();
            for (char chr : chars) {
                int index = chr - 'a';
                if (node.nexts[index] == null) {
                    return 0;
                }
                node = node.nexts[index];
            }
            return node.end;
        }

        // 删掉某个字符串，可以重复删除，每次算1个
        public void delete(String word) {
            // 有这个word则删除，否则不处理
            if (search(word) != 0) {
                Node1 node = root;
                node.pass--;
                char[] chars = word.toCharArray();
                for (char chr : chars) {
                    int index = chr - 'a';
                    // pass 为0,那么下个节点数据就不存在了...
                    if (--node.nexts[index].pass == 0) {
                        node.nexts[index] = null;
                        return;
                    }
                    node = node.nexts[index];
                }
                node.end--;
            }
        }

        // 查询有多少个字符串，是以str做前缀的
        public int prefixNumber(String word) {
            Node1 node = root;
            char[] chars = word.toCharArray();
            for (char chr : chars) {
                int index = chr - 'a';
                // 看下节点是否还在呢
                if (node.nexts[index] == null) {
                    return 0;
                }
                node = node.nexts[index];
            }
            return node.pass;
        }
    }
```



2）哈希表实现

```java
/**
     * 哈系表实现
     */
    public static class Node2 {
        public int pass;
        public int end;
        public HashMap<Integer, Node2> next;

        public Node2() {
            pass = 0;
            end = 0;
            next = new HashMap<>();
        }
    }

    public static class Trie2 {
        public Node2 root;

        public Trie2() {
            root = new Node2();
        }

        // 添加某个字符串，可以重复添加，每次算1个
        public void insert(String word) {
            if (word == null) {
                return;
            }
            Node2 node = root;
            node.pass++;
            char[] chars = word.toCharArray();
            int index = 0;
            // 从左往右遍历 a , b , c
            for (char chr : chars) {
                index = chr;
                // 路径不存在，则新建
                if (!node.next.containsKey(index)) {
                    node.next.put(index, new Node2());
                }
                // 拿到下个节点node，并指向当前node
                node = node.next.get(index);
                node.pass++;
            }
            node.end++;
        }

        // 查询某个字符串在结构中还有几个
        public int search(String word) {
            if (word == null) {
                return 0;
            }
            Node2 node = root;
            char[] chars = word.toCharArray();
            for (char chr : chars) {
                if (!node.next.containsKey((int) chr)) {
                    return 0;
                }
                node = node.next.get((int) chr);
            }
            return node.end;
        }

        // 删掉某个字符串，可以重复删除，每次算1个
        public void delete(String word) {
            // 有这个word则删除，否则不处理
            if (search(word) != 0) {
                Node2 node = root;
                node.pass--;
                char[] chars = word.toCharArray();
                for (char chr : chars) {
                    // pass 为0,那么下个节点数据就不存在了...
                    if (--node.next.get((int) chr).pass == 0) {
                        node.next.remove((int) chr);
                        return;
                    }
                    node = node.next.get((int) chr);
                }
                node.end--;
            }
        }

        // 查询有多少个字符串，是以str做前缀的
        public int prefixNumber(String word) {
            Node2 node = root;
            char[] chars = word.toCharArray();
            for (char chr : chars) {
                // 看下节点是否还在呢
                if (!node.next.containsKey((int) chr)) {
                    return 0;
                }
                node = node.next.get((int) chr);
            }
            return node.pass;
        }
    }
```

## 不基于比较的排序

桶排序思想下的排序：计数排序 & 基数排序 

1)桶排序思想下的排序都是不基于比较的排序

2)时间复杂度为O(N)，额外空间负载度O(M)

3)应用范围有限，需要样本的数据状况满足桶的划分 

**桶排序：**

```java
// only for 0~200 value
public  static void  countSort(int[] arr){
    if (arr == null || arr.length < 2) {
        return;
    }
    int max = Integer.MIN_VALUE;
    for (int i = 0; i < arr.length; i++) {
        max = Math.max(max,arr[i]);
    }
    int[] bucket = new int[max + 1];
    for (int i = 0; i < arr.length; i++) {
        bucket[arr[i]]++;
    }
    int i = 0;
    for (int j = 0; j < bucket.length; j++) {
        while (bucket[j] -- >0){
            arr[i++] = j;
        }
    }
}
```

**基数排序：**

```java
// only for no-negative value
public static void radixSort(int[] arr) {
    if (arr == null || arr.length < 2) {
        return;
    }
    radixSort(arr, 0, arr.length - 1, maxBits(arr));
}

// 求最大位数
private static int maxBits(int[] arr) {
    int max = Integer.MIN_VALUE;
    for (int cur : arr) {
        max = Math.max(max, cur);
    }
    int count = 0;
    while (max != 0) {
        count++;
        max = max / 10;
    }
    return count;
}

public static void radixSort(int[] arr, int L, int R, int digit) {
    int i, j = 0;
    int radix = 10;
    // 准备当前数大小的辅助空间
    int[] help = new int[R - L + 1];
    for (int d = 1; d <= digit; d++) { // 有多少位，就进出多少次
        // 辅助数组是当前数的和
        // count[0] 当前位(d位)是0的数字有多少个
        // count[1] 当前位(d位)是(0和1)的数字有多少个
        // count[2] 当前位(d位)是(0、1和2)的数字有多少个
        // count[i] 当前位(d位)是(0~i)的数字有多少个
        int[] count = new int[radix];
        for (i = L; i <= R; i++) {
            j = getDigit(arr[i], d);
            count[j]++;
        }
        for (i = 1; i < radix; i++) {
            count[i] = count[i] + count[i - 1];
        }
        // 从右往左将arr上的数，依次找到并放入对应的位置
        for (i = R; i >= L; i--) {
            j = getDigit(arr[i], d);
            help[count[j] - 1] = arr[i];
            count[j]--;
        }
        for (i = L, j = 0; i <= R; i++, j++) {
            arr[i] = help[j];
        }
    }
}

private static int getDigit(int v, int d) {
    return ((v / (int) Math.pow(10, d - 1)) % 10);
}
```

## 排序算法的稳定性

稳定性是指同样大小的样本再排序之后不会改变相对次序
对基础类型来说，稳定性毫无意义
对非基础类型来说，稳定性有重要意义
有些排序算法可以实现成稳定的，而有些排序算法无论如何都实现不成稳定的

```txt
1.冒泡排序可以做到稳定
2.选择排序做不到稳定
3.插入排序是否可以做到稳定呢？
4.堆排序做不到稳定
5.快排序的partition方法是不稳定的
6.归并排序可以做到稳定
7.希尔排序是否可以做到稳定呢？
```

## 排序总结：

|            | 时间复杂度 | 额外空间复杂度 | 稳定性 |
| ---------- | ---------- | -------------- | ------ |
| 选择排序   | O(N^2)     | O(1)           | 无     |
| 冒泡排序   | O(N^2)     | O(1)           | 有     |
| 插入排序   | O(N^2)     | O(1)           | 有     |
| 归并排序   | O(N*LogN)  | O(N)           | 有     |
| 随机快排序 | O(N*LogN)  | O(LogN)        | 无     |
| 堆排序     | O(N*LogN)  | O(1)           | 无     |
| 计数排序   | O(N)       | O(M)           | 有     |
| 基数排序   | O(N)       | O(N)           | 有     |

**1）不基于比较的排序，对样本数据有严格要求，不易改写**
**2）基于比较的排序，只要规定好两个样本怎么比大小就可以直接复用**
**3）基于比较的排序，时间复杂度的极限是O(N*logN)**
**4）时间复杂度O(N*logN)、额外空间复杂度低于O(N)、且稳定的基于比较的排序是不存在的。**
**5）为了绝对的速度选快排、为了省空间选堆排、为了稳定性选归并**

## 常见的坑

1）归并排序的额外空间复杂度可以变成O(1)，“归并排序 内部缓存法”，但是将变得不再稳定。

2）“原地归并排序" 是垃圾贴，会让时间复杂度变成O(N^2) 

3）快速排序稳定性改进，“01 stable sort”，但是会对样本数据要求更多

4）在整型数组中，请把奇数放在数组左边，偶数放在数组右边，要求所有奇数之间原始的相对次序不变，所有偶数之间原始相对次序不变且时间复杂度做到O(N)，额外空间复杂度做到O(1)（做不到，这个就是快排的partition方法实现原理（是0放左边，1放右边的问题）（因为快排做不到相对稳定））。

## 工程上对排序的改进

**1)稳定性的考虑** 

**2)充分利用O(N*logN)和O(N^2)排序各自的优势； **

```java
  // 快速排序3.0
    public static void quickSort3(int[] arr) {
        if (arr == null || arr.length < 2) {
            return;
        }
        processor3(arr, 0, arr.length - 1);
    }

    private static void processor3(int[] arr, int L, int R) {
        // 比如当数据样本较小的时候使用其他排序，
        // 数据60是大量实验得到一个概数
        if (R - L = 60) {
            // 这里使用插入排序
            return;
        }
        // 随机快排序
        swap(arr, L + (int) (Math.random() * (R - L + 1)), R);
        int[] M = netherLandsFlag2(arr, L, R);
        processor3(arr, L, M[0] - 1);
        processor3(arr, M[1] + 1, R);
    }
```



