## 二叉树

结构描述：
Class Node {
	V value;
	Node left;
	Node right;
}

### 二叉树的先序、中序、后序遍历

先序：任何子树的处理顺序都是，先头节点、再左子树、然后右子树  -> **(中，左，右)**

中序：任何子树的处理顺序都是，先左子树、再头节点、然后右子树 -> **(左，中，右)**

后序：任何子树的处理顺序都是，先左子树、再右子树、然后头节点 -> **(左，右，中)**

**递归实现树遍历的万能公式**

```java
public static void  f(Node head){
    if(head == null)
        return ;
    // 1 此处打印输出，就是先序遍历
    f(head.left);
    // 2 此处打印输出，就是中序遍历
    f(head.right);
    // 3 此处打印输出，就是后序遍历
}
```

#### 非递归实现先序遍历

**思想：**

#### 非递归实现中序遍历

**思想：**

1. 当前节点cur，cur头树，整条左边界进栈，直到遇到空
2. 栈中弹节点打印，节点的右孩子节点为cur，转步骤1
3. 只要栈为空就停

```java
//中序遍历 左 头 右
public static void mid(Node head) {
    if (head == null)
        return;
    Node cur = head;
    Stack<Node> help = new Stack<>();
    System.out.print("mid - tree : ");
    while (!help.isEmpty() || cur != null) {
        // 先一直看左边
        if (cur != null) {
            help.push(cur);
            cur = cur.left;
        } else {
            cur = help.pop();
            System.out.print(cur.value + " ");
            cur = cur.right;
        }
    }
    System.out.println();
}
```

#### 非递归实现后序遍历

**简单实现：**

```java
//后序遍历 简单版
public static void postSimple(Node head) {
    if (head == null)
        return;
    Stack<Node> help = new Stack<>();
    Stack<Node> res = new Stack<>();
    help.push(head);
    System.out.print("post simple - tree : ");
    while (!help.isEmpty()) {
        head = help.pop(); // help 头 右 左
        res.push(head);
        // 左
        if (head.left != null) {
            help.push(head.left);
        }
        // 右
        if (head.right != null) {
            help.push(head.right);
        }
    }
    // res （左 右 头）
    while (!res.isEmpty()) {
        System.out.print(res.pop().value + " ");
    }
    System.out.println();
}	
```

**复杂实现：**

```java
//后序遍历 高级版
public static void postSupper(Node head) {
    if (head == null)
        return;
    Stack<Node> help = new Stack<>();
    System.out.print("post supper - tree : ");
    help.push(head);
    Node c = null;
    while (!help.isEmpty()) {
        c = help.peek();
        if (c.left != null && head != c.left && head != c.right) {
            help.push(c.left);
        } else if (c.right != null && head != c.right) {
            help.push(c.right);
        } else {
            System.out.print(help.pop().value + " ");
            head = c;
        }
    }
    System.out.println();
}
```

## 实现二叉树的按层遍历

1. 其实就是宽度优先遍历，用队列

   ```java
   public static void level(Node node){
       if(node == null)
           return;
       Queue<Node> queue = new LinkedList<>();
       // 先放入头节点
       queue.add(node);
       while (!queue.isEmpty()){
           Node curt = queue.poll();
           System.out.println(curt.value);
           if(curt.left != null){
               queue.add(curt.left);
           }
           if(curt.right != null){
               queue.add(curt.right);
           }
       }
   }
   ```

2. 可以通过设置flag变量的方式，来发现某一层的结束

## 实现二叉树的序列化和反序列化

1）先序方式序列化和反序列化

```java
// 先序序列化
public static Queue<String> preSerial(Node node) {
    Queue<String> queue = new LinkedList<>();
    pres(node, queue);
    return queue;
}

public static void pres(Node node, Queue<String> queue) {
    if (node == null) {
        queue.add(null);
    }else {
        queue.add(String.valueOf(node.value));
        pres(node.left, queue);
        pres(node.right, queue);
    }
}
```

```java
 // 后序序列化
public static Queue<String> posSerial(Node node) {
     Queue<String> queue = new LinkedList<>();
     pos(node, queue);
     return queue;
 }

 private static void pos(Node node, Queue<String> queue) {
     if (node == null) {
         queue.add(null);
     }else {
         pos(node.left, queue);
         pos(node.right, queue);
         queue.add(String.valueOf(node.value));
     }
 }
```

```java
// 先序反序列化
 public static Node buildByPreQueue(Queue<String> prelist) {
    if (prelist == null || prelist.size() == 0) {
        return null;
    }
    return preb(prelist);
}

private static Node preb(Queue<String> prelist) {
    String value = prelist.poll();
    if (value == null) {
        return null;
    }
    Node node = new Node(Integer.parseInt(value));
    node.left = preb(prelist);
    node.right = preb(prelist);
    return node;
}
```

```java
// 反序反序列化
public static Node buildByPosQueue(Queue<String> poslist) {
    if (poslist == null || poslist.size() == 0) {
        return null;
    }
    // 左右中  ->  stack(中右左)
    Stack<String> stack = new Stack<>();
    while (!poslist.isEmpty()) {
        stack.push(poslist.poll());
    }
    return posb(stack);
}

private static Node posb(Stack<String> posstack) {
    String value = posstack.pop();
    if (value == null) {
        return null;
    }
    Node node = new Node(Integer.parseInt(value));
    node.right = posb(posstack);
    node.left = posb(posstack);
    return node;
}
```

**注意：** 序列化不能用中序方式，因为有歧义，不能唯一确定一棵树
2）按层方式序列化和反序列化

```java
// 层级序列化
public static Queue<String> levelSerial(Node head) {
    Queue<String> ans = new LinkedList<>();
    if(head == null){
        ans.add(null);
    }else {
        ans.add(String.valueOf(head.value));
        Queue<Node> queue = new LinkedList<>();
        queue.add(head);
        while (!queue.isEmpty()){
            head = queue.poll();
            // 先左后右
            if(head.left != null){
                ans.add(String.valueOf(head.left.value));
                queue.add(head.left);
            }else {
                ans.add(null);
            }
            if(head.right != null){
                ans.add(String.valueOf(head.right.value));
                queue.add(head.right);
            }else {
                ans.add(null);
            }
        }
    }
    return ans;
}
```

```java
// 层级反序列化
public static Node buildByLevelQueue(Queue<String> levelList) {
    if (levelList == null || levelList.size() == 0) {
        return null;
    }
    Node head = generateNode(levelList.poll());
    Queue<Node> queue = new LinkedList<>();
    if(head != null){
        queue.add(head);
    }
    Node node = null;
    while (! queue.isEmpty()){
        node = queue.poll();
        node.left = generateNode(levelList.poll());
        node.right = generateNode(levelList.poll());
        if (node.left != null) {
            queue.add(node.left);
        }
        if(node.right != null){
            queue.add(node.right);
        }
    }
    return head;
}
```

## 题目：

### Leetcode:  431 Encode N-ary Tree to Binary Tree

```java
class Codec {
    // Encodes an n-ary tree to a binary tree.
    public TreeNode encode(Node root) {
        if (root == null) {
            return null;
        }
        TreeNode head = new TreeNode(root.val);
        head.left = en(root.children);
        return head;
    }

    private TreeNode en(List<Node> children) {
        TreeNode head = null;
        TreeNode cur = null;
        for(Node child : children){
            TreeNode tn = new TreeNode(child.val);
            if(head == null){
                head = tn;
            }else {
                cur.right = tn;
            }
            cur = tn;
            cur.left = en(child.children);
        }
        return head;
    }

    // Decodes your binary tree to an n-ary tree.
    public Node decode(TreeNode root) {
        if (root == null) {
            return null;
        }
        // 所有左孩子节点就是当前节点的child
        return new Node(root.val,de(root.left));
    }

    private List<Node> de(TreeNode node) {
        List<Node> children = new ArrayList<>();
        while (node != null){
            Node cur = new Node(node.val);
            children.add(cur);
            node = node.left;
        }
        return children;
    }
}
```

### 如何设计一个打印整棵树的打印函数

```java
/**
 * 打印 树节点
 */
public class Code04_PrintBinaryTree {
    public static class Node {
        public int value;
        public Node left;
        public Node right;

        public Node(int data) {
            this.value = data;
        }
    }
    public static void printTree(Node head) {
        System.out.println("Binary Tree:");
        printInOrder(head, 0, "H", 17);
        System.out.println();
    }

    public static String getSpace(int num) {
        String space = " ";
        StringBuffer buf = new StringBuffer("");
        for (int i = 0; i < num; i++) {
            buf.append(space);
        }
        return buf.toString();
    }
    public static void printInOrder(Node head, int height, String to, int len) {
        if (head == null) {
            return;
        }
        printInOrder(head.right, height + 1, "v", len);
        String val = to + head.value + to;
        int lenM = val.length();
        int lenL = (len - lenM) / 2;
        int lenR = len - lenM - lenL;
        val = getSpace(lenL) + val + getSpace(lenR);
        System.out.println(getSpace(height * len) + val);
        printInOrder(head.left, height + 1, "^", len);
    }

    public static void main(String[] args) {
        Node head = new Node(1);
        head.left = new Node(-222222222);
        head.right = new Node(3);
        head.left.left = new Node(Integer.MIN_VALUE);
        head.right.left = new Node(55555555);
        head.right.right = new Node(66);
        head.left.left.right = new Node(777);
        printTree(head);

        head = new Node(1);
        head.left = new Node(2);
        head.right = new Node(3);
        head.left.left = new Node(4);
        head.right.left = new Node(5);
        head.right.right = new Node(6);
        head.left.left.right = new Node(7);
        printTree(head);

        head = new Node(1);
        head.left = new Node(1);
        head.right = new Node(1);
        head.left.left = new Node(1);
        head.right.left = new Node(1);
        head.right.right = new Node(1);
        head.left.left.right = new Node(1);
        printTree(head);

    }
}
```

### 求二叉树最宽的层有多少个节点

**1.使用辅助hash实现**

```java
// 使用辅助hash实现
public static int maxWidthUseMap(Node head) {
    if (head == null) {
        return 0;
    }
    Queue<Node> queue = new LinkedList<>();
    queue.add(head);
    // key 在 哪一层，value
    HashMap<Node, Integer> levelMap = new HashMap<>();
    levelMap.put(head, 1);
    int curLevel = 1; // 当前你正在统计哪一层的宽度
    int curLevelNodes = 0; // 当前层curLevel层，宽度目前是多少
    int max = 0;
    while (!queue.isEmpty()){
        Node cur = queue.poll();
        int curNodeLevel = levelMap.get(cur);
        if(cur.left != null){
            levelMap.put(cur.left,curNodeLevel + 1);
            queue.add(cur.left);
        }
        if(cur.right != null){
            levelMap.put(cur.right,curNodeLevel + 1);
            queue.add(cur.right);
        }
        if(curNodeLevel == curLevel){
            curLevelNodes++;
        }else {
            max = Math.max(max,curLevelNodes);
            curLevel ++;
            curLevelNodes = 1;
        }
    }
    max = Math.max(max,curLevelNodes);
    return max;
}
```

**2.使用有限几个变量实现**



### 给你二叉树中的某个节点，返回该节点的后继节点

**已知：**

```java
Class Node {
	V value;
	Node left;
	Node right;
	Node parent;
}
```

```java
// 两种情况，
// 1.当前节点没有右树，那么他的后继节点就是该节点为当前分支的头节点
// 2.当前节点左右树都右，那么他的后继节点当前节点右节点下所有左节点为null的节点
public static Node getSuccessorNode(Node node) {
    if (node == null) {
        return node;
    }
    if (node.right != null) {
        return getLeftMost(node.right);  // 获取当前节点的最高的父亲节点，符合情况2
    } else {// 无右树
        Node parent = node.parent;
        while (parent != null && parent.right == node) {  // 当前节点是其父亲节点右孩子.符合情况1
            node = parent;
            parent = node.parent;
        }
        return parent;
    }
}

private static Node getLeftMost(Node node) {
    if (node == null) {
        return node;
    }
    while (node.left != null){
        node = node.left;
    }
    return node;
}
```

###  求折痕题

请把一段纸条竖着放在桌子上，然后从纸条的下边向上方对折1次，压出折痕后展开。此时折痕是凹下去的，即折痕突起的方向指向纸条的背面。 如果从纸条的下边向上方连续对折2次，压出折痕后展开，此时有三条折痕，从上到下依次是下折痕、下折痕和上折痕。

给定一个输入参数N，代表纸条都从下边向上方连续对折N次。 请从上到下打印所有折痕的方向。 

例如:N=1时，打印: down N=2时，打印: down down up 

```java
public class Code07_PaperFolding {
    // N 就是对折了几次
    public static void printAllFolds(int N) {
        process(1, N, true);
        System.out.println();
    }

    // 当前你来了一个节点，脑海中想象的！
    // 这个节点在第i层，一共有N层，N固定不变的
    // 这个节点如果是凹的话，down = T
    // 这个节点如果是凸的话，down = F
    // 函数的功能：中序打印以你想象的节点为头的整棵树！
    private static void process(int i, int N, boolean down) {
        if (i > N) {
            return;
        }
        process(i + 1, N, true);
        System.out.print(down ? " 凹 " : " 凸 ");
        process(i + 1, N, false);
    }

    public static void main(String[] args) {
        int N = 4;
        printAllFolds(4);
        /**
         *                    d
         *                d       u
         *              d   u   d   u
         *            d  u d u d u d  u
         */
    }
}
```