# 在无序数组中求第K小的数

## 1）改写快排的方法



## 2）bfprt算法：

思想：

1. 求出特殊值 P

```shell
求P步骤：
1. 脑子中想象无序数组中，每5个数为一组
2.将这每5个数中自己排序，整体是无序得，需要时间复杂O(N)
3.拿出每小组中得中位数，组成一个新小组,复杂度T(N/5)
4.拿出新得数组这个中位数就是P
```

2. 快排第二步骤， 小于P得放左边，等于P得放中间，大于P得放右边(<P  =P >P)  
3. 求剩余小于P得部分数据  ，时间复杂度T(7/10N)

```
T(7/10N) 来源：
据分析：
因为求得大于P得至少数是(0.3N) = (1/10 N *3)
所以，小于P得最多是7/10
```

**时间复杂度：** T(N) = T(N/5) + T(7/10N) + O(N)

**备注：**算法导论9.3节证明该复杂的为O(N)

## 题目：

给定一个无序数组arr中，长度为N，给定一个正数k，返回top k个最大的数
不同时间复杂度三个方法：
1）O(N*logN)
2）O(N + K*logN)
3）O(n + k*logk)

## 蓄水池算法：

解决的问题：

假设有一个源源吐出不同球的机器，

只有装下10个球的袋子，每一个吐出的球，要么放入袋子，要么永远扔掉

如何做到机器吐出每一个球之后，所有吐出的球都等概率被放进袋子里



## 蓄水池算法场景：

解决：时时刻刻中奖得前100名用户

**思路：** 前一百名用户第一次登录就记录，然后依次等概率，等下一个N用户第一次登录之后算出中奖概率，如果中奖将这个用户放入奖池中，从原来得奖池中随机等概率剔除掉一个中奖用户。那么任何地方登录得用户中奖得概率都相同，且是等概率得。

# 经典生成UUID算法：

全球任何地方得东西，生成不同ID且等概率，并且是不能重复得

思路：只需一台机器管理，机器记录两个数据（base数据，和range），使用range去解决并发度，总机器下管理了各个机器（国家），各个机器下还管理了其他各个机器（省），依次类推。

比如：总机器：base=10000开始，range到2000结束 ，