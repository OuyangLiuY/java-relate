## 暴力递归

**暴力递归就是尝试**

1. 把问题转化为规模缩小了的同类问题的子问题
2. 有明确的不需要继续进行递归的条件(base case)
3. 有当得到了子问题的结果之后的决策过程
4. 不记录每一个子问题的解

## 熟悉什么叫尝试？

- 打印n层汉诺塔从最左边移动到最右边的全部过程

- 打印一个字符串的全部子序列

  ```java
  // s -> "abc" ->
  public static List<String> subs(String s) {
      char[] str = s.toCharArray();
      String path = "";
      List<String> ans = new ArrayList<>();
      process1(str, 0, ans, path);
      return ans;
  }
  
  /**
   * str 固定参数
   * 来到了str[index]字符，index是位置
   * str[0..index-1]已经走过了！之前的决定，都在path上
   * 之前的决定已经不能改变了，就是path
   * str[index....]还能决定，之前已经确定，而后面还能自由选择的话，
   * 把所有生成的子序列，放入到ans里去
   */
  private static void process1(char[] str, int index, List<String> ans, String path) {
      if (index == str.length) {
          ans.add(path);
          return;
      }
      // 没要index位置的字符
      process1(str, index + 1, ans, path);
      // 要了index位置的字符
      process1(str, index + 1, ans, path + str[index]);
  }
  ```

- 打印一个字符串的全部子序列，要求不要出现重复字面值的子序列

  ```java
  public static List<String> subsNoRepeat(String s) {
      char[] str = s.toCharArray();
      String path = "";
      HashSet<String> set = new HashSet<>();
      process2(str, 0, set, path);
      return new ArrayList<>(set);
  }
  
  private static void process2(char[] str, int index, HashSet<String> ans, String path) {
      if (index == str.length) {
          ans.add(path);
          return;
      }
      // 没要index位置的字符
      process2(str, index + 1, ans, path);
      // 要了index位置的字符
      process2(str, index + 1, ans, path + str[index]);
  }
  ```

- 打印一个字符串的全部排列

  **方法1：**

  ```java
  public static List<String> permutation1(String s) {
      List<String> ans = new ArrayList<>();
      if (s == null || s.length() == 0) {
          return ans;
      }
      char[] chars = s.toCharArray();
      ArrayList<Character> characters = new ArrayList<>();
      for (char ch : chars) {
          characters.add(ch);
      }
      String path = "";
      func1(characters, ans, path);
      return ans;
  }
  
  // res : abc
  private static void func1(ArrayList<Character> rest, List<String> ans, String path) {
      if (rest.isEmpty()) {
          ans.add(path);
      } else {
          for (int i = 0; i < rest.size(); i++) {
              char cur = rest.get(i);
              // 拿出 a, 看 b，c情况， 到 b，了，拿出 b，然后看 c出情况， -》情况1， a b c 情况2: a, c , b
              rest.remove(i);
              func1(rest, ans, path + cur);
              rest.add(i, cur);
          }
      }
  }
  ```

  **方法2：**

  ```java
  public static List<String> permutation2(String s) {
      List<String> ans = new ArrayList<>();
      if (s == null || s.length() == 0) {
          return ans;
      }
      char[] str = s.toCharArray();
      func2(str, 0, ans);
      return ans;
  }
  
  private static void func2(char[] str, int index, List<String> ans) {
      if (index == str.length) {
          ans.add(String.valueOf(str));
      } else {
          for (int i = index; i < str.length; i++) {
              swap(str, index, i);
              func2(str, index + 1, ans);
              swap(str, index, i);
          }
      }
  }
  
  public static void swap(char[] chs, int i, int j) {
      char tmp = chs[i];
      chs[i] = chs[j];
      chs[j] = tmp;
  }
  ```

- 打印一个字符串的全部排列，要求不要出现重复的排列

  ```java
  public static List<String> permutation3(String s) {
      List<String> ans = new ArrayList<>();
      if (s == null || s.length() == 0) {
          return ans;
      }
      char[] str = s.toCharArray();
      func3(str, 0, ans);
      return ans;
  }
  
  private static void func3(char[] str, int index, List<String> ans) {
      if (index == str.length) {
          ans.add(String.valueOf(str));
      } else {
          boolean[] visited = new boolean[256];
          for (int i = index; i < str.length; i++) {
              // 当前这个位置是否被访问过
              if(!visited[str[i]]){
                  visited[str[i]] = true;
                  swap(str, index, i);
                  func3(str, index + 1, ans);
                  swap(str, index, i);
              }
          }
      }
  }
  ```

## 仰望好的尝试？

给你一个栈，请你逆序这个栈，不能申请额外的数据结构，只能使用递归函数。 如何实现? 

```java
public static void reverse(Stack<Integer> stack) {
    if (stack.isEmpty()) {
        return;
    }
    int i = f(stack);
    reverse(stack);
    stack.push(i);
}

// 栈底元素移除掉
// 上面的元素盖下来
// 返回移除掉的栈底元素
private static int f(Stack<Integer> stack) {
    int result = stack.pop();
    if(stack.isEmpty()){
        return result;
    }else {
        int last  = f(stack);
        stack.push(result);
        return  last;
    }
}
```

