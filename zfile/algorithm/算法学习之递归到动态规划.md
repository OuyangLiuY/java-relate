## 暴力递归

**暴力递归就是尝试**

1. 把问题转化为规模缩小了的同类问题的子问题
2. 有明确的不需要继续进行递归的条件(base case)
3. 有当得到了子问题的结果之后的决策过程
4. 不记录每一个子问题的解

## 熟悉什么叫尝试？

- 打印n层汉诺塔从最左边移动到最右边的全部过程

- 打印一个字符串的全部子序列

  ```java
  // s -> "abc" ->
  public static List<String> subs(String s) {
      char[] str = s.toCharArray();
      String path = "";
      List<String> ans = new ArrayList<>();
      process1(str, 0, ans, path);
      return ans;
  }
  
  /**
   * str 固定参数
   * 来到了str[index]字符，index是位置
   * str[0..index-1]已经走过了！之前的决定，都在path上
   * 之前的决定已经不能改变了，就是path
   * str[index....]还能决定，之前已经确定，而后面还能自由选择的话，
   * 把所有生成的子序列，放入到ans里去
   */
  private static void process1(char[] str, int index, List<String> ans, String path) {
      if (index == str.length) {
          ans.add(path);
          return;
      }
      // 没要index位置的字符
      process1(str, index + 1, ans, path);
      // 要了index位置的字符
      process1(str, index + 1, ans, path + str[index]);
  }
  ```

- 打印一个字符串的全部子序列，要求不要出现重复字面值的子序列

  ```java
  public static List<String> subsNoRepeat(String s) {
      char[] str = s.toCharArray();
      String path = "";
      HashSet<String> set = new HashSet<>();
      process2(str, 0, set, path);
      return new ArrayList<>(set);
  }
  
  private static void process2(char[] str, int index, HashSet<String> ans, String path) {
      if (index == str.length) {
          ans.add(path);
          return;
      }
      // 没要index位置的字符
      process2(str, index + 1, ans, path);
      // 要了index位置的字符
      process2(str, index + 1, ans, path + str[index]);
  }
  ```

- 打印一个字符串的全部排列

  **方法1：**

  ```java
  public static List<String> permutation1(String s) {
      List<String> ans = new ArrayList<>();
      if (s == null || s.length() == 0) {
          return ans;
      }
      char[] chars = s.toCharArray();
      ArrayList<Character> characters = new ArrayList<>();
      for (char ch : chars) {
          characters.add(ch);
      }
      String path = "";
      func1(characters, ans, path);
      return ans;
  }
  
  // res : abc
  private static void func1(ArrayList<Character> rest, List<String> ans, String path) {
      if (rest.isEmpty()) {
          ans.add(path);
      } else {
          for (int i = 0; i < rest.size(); i++) {
              char cur = rest.get(i);
              // 拿出 a, 看 b，c情况， 到 b，了，拿出 b，然后看 c出情况， -》情况1， a b c 情况2: a, c , b
              rest.remove(i);
              func1(rest, ans, path + cur);
              rest.add(i, cur);
          }
      }
  }
  ```

  **方法2：**

  ```java
  public static List<String> permutation2(String s) {
      List<String> ans = new ArrayList<>();
      if (s == null || s.length() == 0) {
          return ans;
      }
      char[] str = s.toCharArray();
      func2(str, 0, ans);
      return ans;
  }
  
  private static void func2(char[] str, int index, List<String> ans) {
      if (index == str.length) {
          ans.add(String.valueOf(str));
      } else {
          for (int i = index; i < str.length; i++) {
              swap(str, index, i);
              func2(str, index + 1, ans);
              swap(str, index, i);
          }
      }
  }
  
  public static void swap(char[] chs, int i, int j) {
      char tmp = chs[i];
      chs[i] = chs[j];
      chs[j] = tmp;
  }
  ```

- 打印一个字符串的全部排列，要求不要出现重复的排列

  ```java
  public static List<String> permutation3(String s) {
      List<String> ans = new ArrayList<>();
      if (s == null || s.length() == 0) {
          return ans;
      }
      char[] str = s.toCharArray();
      func3(str, 0, ans);
      return ans;
  }
  
  private static void func3(char[] str, int index, List<String> ans) {
      if (index == str.length) {
          ans.add(String.valueOf(str));
      } else {
          boolean[] visited = new boolean[256];
          for (int i = index; i < str.length; i++) {
              // 当前这个位置是否被访问过
              if(!visited[str[i]]){
                  visited[str[i]] = true;
                  swap(str, index, i);
                  func3(str, index + 1, ans);
                  swap(str, index, i);
              }
          }
      }
  }
  ```

## 仰望好的尝试？

给你一个栈，请你逆序这个栈，不能申请额外的数据结构，只能使用递归函数。 如何实现? 

```java
public static void reverse(Stack<Integer> stack) {
    if (stack.isEmpty()) {
        return;
    }
    int i = f(stack);
    reverse(stack);
    stack.push(i);
}

// 栈底元素移除掉
// 上面的元素盖下来
// 返回移除掉的栈底元素
private static int f(Stack<Integer> stack) {
    int result = stack.pop();
    if(stack.isEmpty()){
        return result;
    }else {
        int last  = f(stack);
        stack.push(result);
        return  last;
    }
}
```

### 题目一

假设有排成一行的N个位置，记为1~N，N 一定大于或等于 2
开始时机器人在其中的M位置上(M 一定是 1~N 中的一个)
如果机器人来到1位置，那么下一步只能往右来到2位置；
如果机器人来到N位置，那么下一步只能往左来到 N-1 位置；
如果机器人来到中间位置，那么下一步可以往左走或者往右走；
规定机器人必须走 K 步，最终能来到P位置(P也是1~N中的一个)的方法有多少种
给定四个参数 N、M、K、P，返回方法数。 

**方法1：暴力递归**

```java
public static int ways1(int N, int start, int aim, int K) {
    if (N < 2 || start < 1 || start > N || aim < 1 || aim > N || K < 1) {
            return -1;
     }
    return process1(start, K, aim, N);
}

// 机器人当前来到的位置是cur，
// 机器人还有rest步需要走
// 最终目标aim
// 有哪些位置 1~ N
// 返回：机器人从cur出发，走过rest步之后，最终停在aim的方法数，是多少？
private static int process1(int cur, int rest, int aim, int N) {
    if (rest == 0) { // 如果已经不需要走了，走完了！
        return cur == aim ? 1 : 0;
    }
    if (cur == 1) {
        return process1(2, rest - 1, aim, N);
    }
    if (cur == N) {
        return process1(N - 1, rest - 1, aim, N);
    }
    // cur - 1往左， cur + 1 往右走一步
    return process1(cur - 1, rest - 1, aim, N) + process1(cur + 1, rest - 1, aim, N);
}
```

**方法2：暴力递归到动态规划**

```java
public static int ways2(int N, int start, int aim, int K) {
    if (N < 2 || start < 1 || start > N || aim < 1 || aim > N || K < 1) {
            return -1;
     }
    int[][] dp = new int[N + 1][K + 1];
    for (int i = 0; i <= N; i++) {
        for (int j = 0; j <= K; j++) {
            dp[i][j] = -1;
        }
    }
    return process2(start, K, aim, N, dp);
}

private static int process2(int cur, int rest, int aim, int N, int[][] dp) {
    if (dp[cur][rest] != -1) {
        return dp[cur][rest];
    }
    int ans = 0;
    if (rest == 0) { // 如果已经不需要走了，走完了！
        ans = cur == aim ? 1 : 0;
    } else if (cur == 1) {
        ans = process1(2, rest - 1, aim, N);
    } else if (cur == N) {
        ans = process1(N - 1, rest - 1, aim, N);
    } else {
        // cur - 1往左， cur + 1 往右走一步
        ans = process1(cur - 1, rest - 1, aim, N) + process1(cur + 1, rest - 1, aim, N);
    }
    dp[cur][rest] = ans;
    return ans;
}
```

**方法3：动态规划**

```java
// 分析：
// 根据递归中条件进行分析：
public static int ways3(int N, int start, int aim, int K) {
    if (N < 2 || start < 1 || start > N || aim < 1 || aim > N || K < 1) {
            return -1;
     }
    int[][] dp = new int[N + 1][K + 1];
    // 根据递归中条件进行分析：
    // 1. rest = 0, cur = aim : 1 说明终点这个位置为1
    dp[aim][0] = 1;
    // 第一列中aim行的第一个树数已赋值
    for (int rest = 1; rest <= K; rest++) {
        // 2. cur == 1;
        dp[1][rest] = dp[2][rest - 1];
        // 4. else
        for (int cur = 2; cur < N; cur++) {
            dp[cur][rest] = dp[cur - 1][rest - 1] + dp[cur + 1][rest - 1];
        }
        // 3. cur == N
        dp[N][rest] = dp[N - 1][rest - 1];
    }
    return dp[start][K];
}
```

### **题目二：**

给定一个整型数组arr，代表数值不同的纸牌排成一条线
玩家A和玩家B依次拿走每张纸牌
规定玩家A先拿，玩家B后拿
但是每个玩家每次只能拿走最左或最右的纸牌
玩家A和玩家B都绝顶聪明
请返回最后获胜者的分数。

**方法1：暴力递归**

```java
public static int win1(int[] arr) {
    int first = f1(arr, 0, arr.length - 1);
    int second = g1(arr, 0, arr.length - 1);
    return Math.max(first, second);
}

// arr[L..R]，先手获得的最好分数返回
public static int f1(int[] arr, int L, int R) {
    if (L == R) {
        return arr[L];
    }
    int p1 = arr[L] + g1(arr, L + 1, R); // 拿走了L位置的数
    int p2 = arr[R] + g1(arr, L, R - 1); // 拿走了R位置的数
    return Math.max(p1, p2);
}

// arr[L..R]，后手获得的最好分数返回
public static int g1(int[] arr, int L, int R) {
    if (L == R) {
        return 0;
    }
    int p1 = f1(arr, L + 1, R);  // 对手拿走了L位置的数
    int p2 = f1(arr, L, R - 1); // 对手拿走了R位置的数
    return Math.min(p1, p2);
}
```

**方法2：暴力递归到动态规划**

```java
public static int win2(int[] arr) {
    int N = arr.length;
    int[][] fmap = new int[N][N];
    int[][] gmap = new int[N][N];
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            fmap[i][j] = -1;
            gmap[i][j] = -1;
        }
    }
    int first = f2(arr, 0, arr.length - 1, fmap, gmap);
    int second = g2(arr, 0, arr.length - 1, fmap, gmap);
    return Math.max(first, second);
}

// arr[L..R]，先手获得的最好分数返回
public static int f2(int[] arr, int L, int R, int[][] fmap, int[][] gmap) {
    if (fmap[L][R] != -1) {
        return fmap[L][R];
    }
    int ans = 0;
    if (L == R) {
        ans = arr[L];
    } else {
        int p1 = arr[L] + g2(arr, L + 1, R, fmap, gmap); // 拿走了L位置的数
        int p2 = arr[R] + g2(arr, L, R - 1, fmap, gmap); // 拿走了R位置的数
        ans = Math.max(p1, p2);
    }
    fmap[L][R] = ans;
    return ans;
}

// arr[L..R]，后手获得的最好分数返回
public static int g2(int[] arr, int L, int R, int[][] fmap, int[][] gmap) {
    if (gmap[L][R] != -1) {
        return gmap[L][R];
    }
    int ans = 0;
    if (L != R) {
        int p1 = f2(arr, L + 1, R, fmap, gmap);  // 对手拿走了L位置的数
        int p2 = f2(arr, L, R - 1, fmap, gmap); // 对手拿走了R位置的数
        ans = Math.min(p1, p2);
    }
    gmap[L][R] = ans;
    return ans;
}
```

**方法3：动态规划**

```java
public static int win3(int[] arr) {
    if (arr == null || arr.length == 0) {
        return 0;
    }
    int N = arr.length;
    int[][] fmap = new int[N][N];
    int[][] gmap = new int[N][N];
    // 对角线
    for (int i = 0; i < N; i++) {
        fmap[i][i] = arr[i];
    }
    for (int startCol = 1; startCol < N; startCol++) {
        int L = 0;
        int R = startCol;
        // 防止越界
        while (R < N) {
            fmap[L][R] = Math.max(arr[L] + gmap[L + 1][R], arr[R] + gmap[L][R - 1]);
            gmap[L][R] = Math.min(fmap[L + 1][R], fmap[L][R - 1]);
            L++;
            R++;
        }
    }
    return Math.max(fmap[0][N - 1], gmap[0][N - 1]);
}
```

### 题目三：

给定两个长度都为N的数组weights和values，
weights[i]和values[i]分别代表 i号物品的重量和价值。
给定一个正数bag，表示一个载重bag的袋子，
你装的物品不能超过这个重量。
返回你能装下最多的价值是多少? 

**方法1：暴力递归**

```java
public static int maxValue1(int[] w, int[] v, int bag) {
    if (w == null || v == null || w.length != v.length || bag < 0) {
        return -1;
    }
    return process1(w, v, 0, bag);
}

public static int process1(int[] w, int[] v, int index, int rest) {
    if (rest < 0) {
        return -1;
    }
    if (index == w.length) {
        return 0;
    }
    // 要当前位置得,但是
    int next = process1(w, v, index + 1, rest - w[index]);
    int p1 = 0;
    if (next != -1) {
        p1 = v[index] + next;
    }
    // 不要当前位置
    int p2 = process1(w, v, index + 1, rest);
    return Math.max(p1, p2);
}
```

**方法2：动态规划**

```java
public static int dp(int[] w, int[] v, int bag) {
    if (w == null || v == null || w.length != v.length || bag < 0) {
        return -1;
    }
    int N = v.length;
    int[][] dp = new int[N + 1][bag + 1];
    // index == w.length 说明最后一行都是0
    for (int index = N - 1; index >= 0; index--) {
        for (int rest = 0; rest <= bag; rest++) {
            // 不要当前位置
            int p1 = dp[index + 1][rest];
            // 要当前位置得,但是
            int next = rest - w[index] < 0 ? -1 : dp[index + 1][rest - w[index]];
            int p2 = 0;
            if (next != -1) {
                p2 = v[index] + next;
            }
            dp[index][rest] = Math.max(p1, p2);
        }
    }
    return dp[0][bag];
}
```

### 题目四：

规定1和A对应、2和B对应、3和C对应...26和Z对应
那么一个数字字符串比如"111”就可以转化为:
"AAA"、"KA"和"AK"
给定一个只有数字字符组成的字符串str，返回有多少种转化结果

方法1：暴力递归

```java
// str只含有数字字符0~9
// 返回多少种转化方案
public static int number(String str) {
    if (str == null || str.length() == 0) {
        return 0;
    }
    return process(str.toCharArray(), 0);
}

// str[0..i-1]转化无需过问
// str[i.....]去转化，返回有多少种转化方法
public static int process(char[] str, int i) {
    if (i == str.length) {
        return 1;
    }
    // i没到最后，说明有字符
    if (str[i] == '0') { // 如果有单个0则不能转化
        return 0;
    }
    //单个字符有可能性
    int ways = process(str, i + 1);
    // 两个字符组合
    if (i + 1 < str.length && ((str[i] - '0') * 10 + (str[i + 1] - '0')) < 27) {
        ways += process(str, i + 2);
    }
    return ways;
}
```

方法2：动态规划

```java
public static int dp(String s) {
    if (s == null || s.length() == 0) {
        return 0;
    }
    char[] str = s.toCharArray();
    int N = str.length;
    int[] dp = new int[N + 1];
    dp[N] = 1;
    for (int index = N - 1; index >= 0; index--) {
        if (str[index] != '0') { // 如果有单个0则不能转化
            //单个字符有可能性
            int ways = dp[index + 1];
            // 两个字符组合
            if (index + 1 < str.length && ((str[index] - '0') * 10 + (str[index + 1] - '0')) < 27) {
                ways += dp[index + 2];
            }
            dp[index] = ways;
        }
    }
    return dp[0];
}
```

### 题目五：

给定一个字符串str，给定一个字符串类型的数组arr，出现的字符都是小写英文
arr每一个字符串，代表一张贴纸，你可以把单个字符剪开使用，目的是拼出str来
返回需要至少多少张贴纸可以完成这个任务。
例子：str= "babac"，arr = {"ba","c","abcd"}
ba + ba + c  3  abcd + abcd 2  abcd+ba 2
所以返回2

leetcode：https://leetcode.com/problems/stickers-to-spell-word

**方法1：暴力递归**

```java
public static int minStickers1(String[] stickers, String target) {
    int ans = process1(stickers, target);
    return ans == Integer.MAX_VALUE ? -1 : ans;
}

// 所有贴纸stickers，每一种贴纸都有无穷张
// target
// 最少张数
private static int process1(String[] stickers, String target) {
    if (target.length() == 0) {
        return 0;
    }
    int min = Integer.MAX_VALUE;
    // 每一种都以first开始尝试
    for (String first : stickers) {
        // 剩余还有多少个字符不符合
        String rest = minus(target, first);
        if (rest.length() != target.length()) {
            min = Math.min(min, process1(stickers, rest));
        }
    }
    return min + (min != Integer.MAX_VALUE ? 1 : 0);
}

public static String minus(String s1, String s2) {
    char[] str1 = s1.toCharArray();
    char[] str2 = s2.toCharArray();
    int[] count = new int[26];
    for (char cha : str1) {
        count[cha - 'a']++;
    }
    for (char cha : str2) {
        count[cha - 'a']--;
    }
    StringBuilder builder = new StringBuilder();
    for (int i = 0; i < 26; i++) {
        // 说明当前位置还有字符
        if (count[i] > 0) {
            for (int j = 0; j < count[i]; j++) {
                builder.append((char) (i + 'a'));
            }
        }
    }
    return builder.toString();
}
```

**方法2：暴力递归**

```java
public static int minStickers2(String[] stickers, String target) {
    int N = stickers.length;
    // 关键优化(用词频表替代贴纸数组)
    int[][] counts = new int[N][26];
    for (int i = 0; i < N; i++) {
        char[] chars = stickers[i].toCharArray();
        for (char cha : chars) {
            counts[i][cha - 'a']++;
        }
    }
    int ans = process2(counts, target);
    return ans == Integer.MAX_VALUE ? -1 : ans;
}

// stickers[i] 数组，当初i号贴纸的字符统计 int[][] stickers -> 所有的贴纸
// 每一种贴纸都有无穷张
// 返回搞定target的最少张数
// 最少张数
private static int process2(int[][] stickers, String t) {
    if (t.length() == 0) {
        return 0;
    }
    // target做出词频统计
    // target  aabbc  2 2 1..
    //                0 1 2..
    char[] target = t.toCharArray();
    int[] tcounts = new int[26];
    for (char cha : target) {
        tcounts[cha - 'a']++;
    }
    int N = stickers.length;
    int min = Integer.MAX_VALUE;
    for (int i = 0; i < N; i++) {
        // 尝试第一张贴纸是谁
        int[] sticker = stickers[i];
        // 最关键的优化(重要的剪枝!这一步也是贪心!)
        // 这句判断说明，当前需要拼接得target字符存在于sticker中
        if (sticker[target[0] - 'a'] > 0) {
            StringBuilder builder = new StringBuilder();
            for (int j = 0; j < 26; j++) {
                if (tcounts[j] > 0) {
                    int nums = tcounts[j] - sticker[j];
                    for (int k = 0; k < nums; k++) {
                        builder.append((char) (j + 'a'));
                    }
                }
            }
            String rest = builder.toString();
            min = Math.min(min, process2(stickers, rest));
        }
    }
    return min + (min != Integer.MAX_VALUE ? 1 : 0);
}
```

**方法3：暴力递归到动态规划**

```java
public static int minStickers3(String[] stickers, String target) {
    int N = stickers.length;
    int[][] counts = new int[N][26];
    for (int i = 0; i < N; i++) {
        char[] str = stickers[i].toCharArray();
        for (char cha : str) {
            counts[i][cha - 'a']++;
        }
    }
    HashMap<String, Integer> dp = new HashMap<>();
    dp.put("", 0);
    int ans = process3(counts, target, dp);
    return ans == Integer.MAX_VALUE ? -1 : ans;
}

public static int process3(int[][] stickers, String t, HashMap<String, Integer> dp) {
    if (dp.containsKey(t)) {
        return dp.get(t);
    }
    char[] target = t.toCharArray();
    int[] tcounts = new int[26];
    for (char cha : target) {
        tcounts[cha - 'a']++;
    }
    int N = stickers.length;
    int min = Integer.MAX_VALUE;
    for (int i = 0; i < N; i++) {
        int[] sticker = stickers[i];
        if (sticker[target[0] - 'a'] > 0) {
            StringBuilder builder = new StringBuilder();
            for (int j = 0; j < 26; j++) {
                if (tcounts[j] > 0) {
                    int nums = tcounts[j] - sticker[j];
                    for (int k = 0; k < nums; k++) {
                        builder.append((char) (j + 'a'));
                    }
                }
            }
            String rest = builder.toString();
            min = Math.min(min, process3(stickers, rest, dp));
        }
    }
    int ans = min + (min != Integer.MAX_VALUE ? 1 : 0);
    dp.put(t, ans);
    return ans;
}
```

### 题目六：

给定两个字符串str1和str2，
返回这两个字符串的最长公共子序列长度

比如 ： str1 = “a12b3c456d”,str2 = “1ef23ghi4j56k”
最长公共子序列是“123456”，所以返回长度6

leetcode：https://leetcode.com/problems/longest-common-subsequence/

**方法1：暴力递归**

```java
public static int longestCommonSubsequence(String s1, String s2) {
    if (s1 == null || s2 == null || s1.length() == 0 || s2.length() == 0) {
        return 0;
    }
    char[] str1 = s1.toCharArray();
    char[] str2 = s2.toCharArray();
    return process(str1, str2, str1.length - 1, str2.length - 1);
}

private static int process(char[] str1, char[] str2, int i1, int i2) {
    if (i1 == 0 && i2 == 0) {
        return str1[i1] == str2[i2] ? 1 : 0;
    } else if (i1 == 0) {
        if (str1[i1] == str2[i2]) {
            return 1;
        } else {
            return process(str1, str2, i1, i2 - 1);
        }
    } else if (i2 == 0) {
        if (str1[i1] == str2[i2]) {
            return 1;
        } else {
            return process(str1, str2, i1 - 1, i2);
        }
    } else {
        // 算字符i1，算i2或不算i2
        int p1 = process(str1, str2, i1 - 1, i2);
        // 算字符i2，算i1或不算i1
        int p2 = process(str1, str2, i1, i2 - 1);
        // 都算
        int p3 = str1[i1] == str2[i2] ? (1 + process(str1, str2, i1 - 1, i2 - 1)) : 0;
        return Math.max(p1, Math.max(p2, p3));
    }
}
```

**方法2：动态规划**

```java
public static int longestCommonSubsequence2(String s1, String s2) {
    if (s1 == null || s2 == null || s1.length() == 0 || s2.length() == 0) {
        return 0;
    }
    char[] str1 = s1.toCharArray();
    char[] str2 = s2.toCharArray();
    int N = str1.length;
    int M = str2.length;
    int[][] dp = new int[N][M];
    //条件1
    dp[0][0] = str1[0] == str2[0] ? 1 : 0;
    for (int i = 1; i < M; i++) {
        dp[0][i] = str1[0] == str2[i] ? 1 : dp[0][i - 1];
    }
    for (int i = 1; i < N; i++) {
        dp[i][0] = str1[i] == str2[0] ? 1 : dp[i - 1][0];
    }
    for (int i = 1; i < N; i++) {
        for (int j = 1; j < M; j++) {
            int p1 = dp[i - 1][j];
            int p2 = dp[i][j - 1];
            int p3 = str1[i] == str2[j] ? (1 + dp[i - 1][j - 1]) : 0;
            dp[i][j] = Math.max(p1, Math.max(p2, p3));
        }
    }
    return dp[N - 1][M - 1];
}
```

### 题目七：

给定一个字符串str，返回这个字符串的最长回文子序列长度
比如 ： str = “a12b3c43def2ghi1kpm”
最长回文子序列是“1234321”或者“123c321”，返回长度7

leetcode：https://leetcode.com/problems/longest-palindromic-subsequence/

**方法1：暴力递归**

```java
// 这里使用思路二解题
//解题思路二：重暴力递归，然后改动态规划
public static int longestPalindromeSubseq(String str) {
    if (str == null || str.length() == 0) {
        return 0;
    }
    char[] chars = str.toCharArray();
    return process(chars, 0, chars.length - 1);
}

public static int process(char[] str, int L, int R) {
    if (L == R) {
        return 1;
    }
    // 相邻两个字符是否相同
    if (L == R - 1) {
        return str[L] == str[R] ? 2 : 1;
    }
    // 三种情况，
    // 算L，不算R
    int p1 = process(str, L, R - 1);
    // 不算L，算R
    int p2 = process(str, L + 1, R);
    // 不算L，不算R
    int p3 = process(str, L + 1, R - 1);
    // 两个都要的情况下，必须是str[L] == str[R]
    int p4 = str[L] == str[R] ? (2 + process(str, L + 1, R - 1)) : 0;
    return Math.max(Math.max(p1, p2), Math.max(p3, p4));
}
```

**方法2：动态规划**

```java
public static int longestPalindromeSubseq1(String str) {
    if (str == null || str.length() == 0) {
        return 0;
    }
    char[] chars = str.toCharArray();
    int N = chars.length;
    int[][] dp = new int[N][N];
    dp[N - 1][N - 1] = 1;
    for (int i = 0; i < N - 1; i++) {
        dp[i][i] = 1;
        dp[i][i + 1] = chars[i] == chars[i + 1] ? 2 : 1;
    }
    //从下往上赋值
    for (int L = N - 3; L >= 0; L--) {
        for (int R = L + 2; R < N; R++) {
            /*int p1 = dp[L][R - 1];
            // 不算L，算R
            int p2 = dp[L + 1][R];
            // 不算L，不算R
            int p3 = dp[L + 1][R - 1];
            // 两个都要的情况下，必须是str[L] == str[R]
            int p4 = chars[L] == chars[R] ? (2 + dp[L + 1][R - 1]) : 0;
            dp[L][R] = Math.max(Math.max(p1, p2), Math.max(p3, p4));
            */
            //根据以上条件可以得知，当前位置的数，一定大于左边的数，一定大于下面的数，一定大于坐下的数，故可以优化如下
            dp[L][R] = Math.max(dp[L][R - 1], dp[L + 1][R]);
            if (chars[L] == chars[R]) {
                dp[L][R] = Math.max(dp[L][R], 2 + dp[L + 1][R - 1]);
            }
        }
    }
    return dp[0][chars.length - 1];
}
```

**方法3：数组反转动态规划**

```java
// 解题思路一：str正序的长顺序对，str逆序的最长顺序对，两者相同就是最大会文子序列
public static int longestPalindromeSubseq3(String s) {
    if (s == null || s.length() == 0) {
        return 0;
    }
    if (s.length() == 1) {
        return 1;
    }
    char[] str = s.toCharArray();
    char[] reverse = reverse(str);
    return longestCommonSubsequence(str, reverse);
}
public static char[] reverse(char[] str) {
    int N = str.length;
    char[] reverse = new char[str.length];
    for (int i = 0; i < str.length; i++) {
        reverse[--N] = str[i];
    }
    return reverse;
}
private static int longestCommonSubsequence(char[] str1, char[] str2) {
    int N = str1.length;
    int M = str2.length;
    int[][] dp = new int[N][M];
    dp[0][0] = str1[0] == str2[0] ? 1 : 0;
    for (int i = 1; i < N; i++) {
        dp[i][0] = str1[i] == str2[0] ? 1 : dp[i - 1][0];
    }
    for (int j = 1; j < M; j++) {
        dp[0][j] = str1[0] == str2[j] ? 1 : dp[0][j - 1];
    }
    for (int i = 1; i < N; i++) {
        for (int j = 1; j < M; j++) {
            dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            if (str1[i] == str2[j]) {
                dp[i][j] = Math.max(dp[i][j], dp[i - 1][j - 1] + 1);
            }
        }
    }
    return dp[N - 1][M - 1];
}
```

### 题目八：

请同学们自行搜索或者想象一个象棋的棋盘，
然后把整个棋盘放入第一象限，棋盘的最左下角是(0,0)位置
那么整个棋盘就是横坐标上9条线、纵坐标上10条线的区域
给你三个 参数 x，y，k
返回“马”从(0,0)位置出发，必须走k步
最后落在(x,y)上的方法数有多少种? 

**方法1：暴力递归**

```java
// 当前来到的位置是（x,y）
// 还剩下rest步需要跳
// 跳完rest步，正好跳到a，b的方法数是多少？
// 10 * 9
public static int jump(int a, int b, int k) {
    return process(0, 0, k, a, b);
}

private static int process(int x, int y, int rest, int a, int b) {
    if (x < 0 || x > 9 || y < 0 || y > 8) {
        return 0;
    }
    if (rest == 0) {
        return x == a && y == b ? 1 : 0;
    }
    //根据棋盘样式，一个棋子在xy位置，他具有8个方向跳动方式
    int ways = process(x + 2, y + 1, rest - 1, a, b);
    ways += process(x + 1, y + 2, rest - 1, a, b);
    ways += process(x - 1, y + 2, rest - 1, a, b);
    ways += process(x - 2, y + 1, rest - 1, a, b);
    ways += process(x - 2, y - 1, rest - 1, a, b);
    ways += process(x - 1, y - 2, rest - 1, a, b);
    ways += process(x + 1, y - 2, rest - 1, a, b);
    ways += process(x + 2, y - 1, rest - 1, a, b);
    return ways;
}
```

**方法2：动态规划**

```java
public static int dp(int a, int b, int k) {
    int[][][] dp = new int[10][9][k + 1];
    // 第一层
    dp[a][b][0] = 1;
    for (int rest = 1; rest <= k; rest++) {
        for (int x = 0; x < 10; x++) {
            for (int y = 0; y < 9; y++) {
                int ways = pick(dp, x + 2, y + 1, rest - 1);
                ways += pick(dp, x + 1, y + 2, rest - 1);
                ways += pick(dp, x - 1, y + 2, rest - 1);
                ways += pick(dp, x - 2, y + 1, rest - 1);
                ways += pick(dp, x - 2, y - 1, rest - 1);
                ways += pick(dp, x - 1, y - 2, rest - 1);
                ways += pick(dp, x + 1, y - 2, rest - 1);
                ways += pick(dp, x + 2, y - 1, rest - 1);
                dp[x][y][rest] = ways;
            }
        }
    }
    return dp[0][0][k];
}
```

### 题目九： 难

给定一个数组arr，arr[i]代表第i号咖啡机泡一杯咖啡的时间
给定一个正数N，表示N个人等着咖啡机泡咖啡，每台咖啡机只能轮流泡咖啡
只有一台咖啡机，一次只能洗一个杯子，时间耗费a，洗完才能洗下一杯
每个咖啡杯也可以自己挥发干净，时间耗费b，咖啡杯可以并行挥发
假设所有人拿到咖啡之后立刻喝干净，
返回从开始等到所有咖啡机变干净的最短时间
三个参数：int[] arr、int N，int a、int b

**方法1：暴力递归**

```java
// 验证的方法
// 彻底的暴力
// 很慢但是绝对正确
public static int right(int[] arr, int n, int a, int b) {
    int[] times = new int[arr.length];
    int[] drink = new int[n];
    return forceMake(arr, times, 0, drink, n, a, b);
}

// 每个人暴力尝试用每一个咖啡机给自己做咖啡
public static int forceMake(int[] arr, int[] times, int kth, int[] drink, int n, int a, int b) {
    if (kth == n) {
        int[] drinkSorted = Arrays.copyOf(drink, kth);
        Arrays.sort(drinkSorted);
        return forceWash(drinkSorted, a, b, 0, 0, 0);
    }
    int time = Integer.MAX_VALUE;
    for (int i = 0; i < arr.length; i++) {
        int work = arr[i];
        int pre = times[i];
        drink[kth] = pre + work;
        times[i] = pre + work;
        time = Math.min(time, forceMake(arr, times, kth + 1, drink, n, a, b));
        drink[kth] = 0;
        times[i] = pre;
    }
    return time;
}
```

**方法2：使用小根堆暴力递归**

```java
// 优良一点的暴力尝试的方法
public static int minTime1(int[] arr, int n, int a, int b) {
    PriorityQueue<Machine> heap = new PriorityQueue<>(new MachineComparator());
    for (int i = 0; i < arr.length; i++) {
        heap.add(new Machine(0, arr[i]));
    }
    int[] drinks = new int[n];
    for (int i = 0; i < n; i++) {
        Machine cur = heap.poll();
        cur.timePoint += cur.workTime;
        drinks[i] = cur.timePoint;
        heap.add(cur);
    }
    return bestTime(drinks, a, b, 0, 0);
}

// drinks 所有杯子可以开始洗的时间
// wash 单杯洗干净的时间（串行）
// air 挥发干净的时间(并行)
// free 洗的机器什么时候可用
// drinks[index.....]都变干净，最早的结束时间（返回）
public static int bestTime(int[] drinks, int wash, int air, int index, int free) {
    if (index == drinks.length) {
        return 0;
    }
    // index号杯子 决定洗
    int selfClean1 = Math.max(drinks[index], free) + wash;
    int restClean1 = bestTime(drinks, wash, air, index + 1, selfClean1);
    int p1 = Math.max(selfClean1, restClean1);
    // index号杯子 决定挥发
    int selfClean2 = drinks[index] + air;
    int restClean2 = bestTime(drinks, wash, air, index + 1, free);
    int p2 = Math.max(selfClean2, restClean2);
    return Math.min(p1, p2);
}
public static class Machine {
        public int timePoint;
        public int workTime;

        public Machine(int t, int w) {
            timePoint = t;
            workTime = w;
        }
    }
    public static class MachineComparator implements Comparator<Machine> {
        @Override
        public int compare(Machine o1, Machine o2) {
            return (o1.timePoint + o1.workTime) - (o2.timePoint + o2.workTime);
        }
    }
```

**方法3：动态规划**

```java
// 贪心+优良尝试改成动态规划
public static int minTime2(int[] arr, int n, int a, int b) {
    PriorityQueue<Machine> heap = new PriorityQueue<>(new MachineComparator());
    for (int j : arr) {
        heap.add(new Machine(0, j));
    }
    int[] drinks = new int[n];
    for (int i = 0; i < n; i++) {
        Machine cur = heap.poll();
        cur.timePoint += cur.workTime;
        drinks[i] = cur.timePoint;
        heap.add(cur);
    }
    return bestTimeDp(drinks, a, b);
}

public static int bestTimeDp(int[] drinks, int wash, int air) {
    int N = drinks.length;
    int maxFree = 0;
    for (int i = 0; i < drinks.length; i++) {
        maxFree = Math.max(maxFree, drinks[i]) + wash;
    }
    int[][] dp = new int[N + 1][maxFree + 1];
    for (int index = N - 1; index >= 0; index--) {
        for (int free = 0; free <= maxFree; free++) {
            int selfClean1 = Math.max(drinks[index], free) + wash;
            if (selfClean1 > maxFree) {
                break;
            }
            // index号杯子 决定洗
            int restClean1 = dp[index + 1][selfClean1];
            int p1 = Math.max(selfClean1, restClean1);
            // index号杯子 决定挥发
            int selfClean2 = drinks[index] + air;
            int restClean2 = dp[index + 1][free];
            int p2 = Math.max(selfClean2, restClean2);
            dp[index][free] = Math.min(p1, p2);
        }
    }
    return dp[0][0];
}
```

### 题目十：

给定一个二维数组matrix，一个人必须从左上角出发，最后到达右下角
沿途只可以向下或者向右走，沿途的数字都累加就是距离累加和
返回最小距离累加和

**方法1：动态规划**

```java
// 动态规划
public static int minPathSum1(int[][] m) {
    if (m == null || m.length == 0 || m[0] == null || m[0].length == 0) {
        return 0;
    }
    int row = m.length;
    int col = m[0].length;
    int[][] dp = new int[row][col];
    dp[0][0] = m[0][0];
    // 第一行
    for (int i = 1; i < col; i++) {
        dp[0][i] = dp[0][i - 1] + m[0][i];
    }
    // 第一列
    for (int i = 1; i < row; i++) {
        dp[i][0] = dp[i - 1][0] + m[i][0];
    }
    for (int r = 1; r < row; r++) {
        for (int c = 1; c < col; c++) {
            dp[r][c] = Math.min(dp[r][c - 1], dp[r - 1][c]) + m[r][c];
        }
    }
    return dp[row - 1][col - 1];
}
```

**方法2：动态规划之空间压缩**

```java
// 空间压缩优化，二维转化成一维即可
// 当i，j位置的数据依赖左，上，左上的数据时，都可以转成一维的表
public static int minPathSum2(int[][] m) {
    if (m == null || m.length == 0 || m[0] == null || m[0].length == 0) {
        return 0;
    }
    int row = m.length;
    int col = m[0].length;
    int[] dp = new int[col];
    dp[0] = m[0][0];
    // 初始化第一行
    for (int j = 1; j < col; j++) {
        dp[j] = dp[j - 1] + m[0][j];
    }
    for (int i = 1; i < row; i++) {
        // 第i行第一个值
        dp[0] += m[i][0];
        for (int j = 1; j < col; j++) {
            dp[j] = Math.min(dp[j - 1], dp[j]) + m[i][j];
        }
    }
    return dp[col - 1];
}
```

### 题目十一：

arr是货币数组，其中的值都是正数。再给定一个正数aim。
每个值都认为是一张货币，
即便是值相同的货币也认为每一张都是不同的，
返回组成aim的方法数
例如：arr = {1,1,1}，aim = 2
第0个和第1个能组成2，第1个和第2个能组成2，第0个和第2个能组成2
一共就3种方法，所以返回3

**方法1：暴力递归**

```java
public static int coinWays(int[] arr, int aim) {
    return process(arr, 0, aim);
}

private static int process(int[] arr, int index, int rest) {
    if (rest < 0) {
        return 0;
    }
    if (index == arr.length) {
        return rest == 0 ? 1 : 0;
    } else {
        // 要当前位置剩余aim要减去当前位置的值，不要当前位置，aim不变，直接下一次递归
        return process(arr, index + 1, rest) + process(arr, index + 1, rest - arr[index]);
    }
}
```

**方法2：动态规划**

```java
public static int dp(int[] arr, int aim) {
    if (aim == 0) {
        return 1;
    }
    int N = arr.length;
    int M = aim;
    int[][] dp = new int[N + 1][M + 1];
    // 条件一
    dp[N][0] = 1;
    // 从下往上的 N-1 位置
    for (int index = N - 1; index >= 0; index--) {
        // 从左往右
        for (int rest = 0; rest <= M; rest++) {
            dp[index][rest] = dp[index + 1][rest] + (rest - arr[index] >= 0 ? dp[index + 1][rest - arr[index]] : 0);
        }
    }
    return dp[0][aim];
}
```

### 题目十二：

arr是面值数组，其中的值都是正数且没有重复。再给定一个正数aim。
每个值都认为是一种面值，且认为张数是无限的。
返回组成aim的方法数
例如：arr = {1,2}，aim = 4
方法如下：1+1+1+1、1+1+2、2+2
一共就3种方法，所以返回3

**方法1：暴力递归**

```java
public static int coinsWay(int[] arr, int aim) {
    if (arr == null || arr.length == 0 || aim < 0) {
        return 0;
    }
    return process(arr, 0, aim);
}

private static int process(int[] arr, int index, int rest) {
    if (index == arr.length) {
        return rest == 0 ? 1 : 0;
    }
    int ways = 0;
    // 每一张都是无数的，但是不能大于 rest / arr[index] 张
    for (int zhang = 0; zhang * arr[index] <= rest; zhang++) {
        ways += process(arr, index + 1, rest - (zhang * arr[index]));
    }
    return ways;
}
```

**方法2：动态规划**

```java
public static int dp1(int[] arr, int aim) {
    if (arr == null || arr.length == 0 || aim < 0) {
        return 0;
    }
    int N = arr.length;
    int[][] dp = new int[N + 1][aim + 1];
    dp[N][0] = 1;
    for (int index = N - 1; index >= 0; index--) {
        for (int rest = 0; rest <= aim; rest++) {
            int ways = 0;
            // 每一张都是无数的，但是不能大于 rest / arr[index] 张
            for (int zhang = 0; zhang * arr[index] <= rest; zhang++) {
                ways += dp[index + 1][rest - (zhang * arr[index])];
            }
            dp[index][rest] = ways;
        }
    }
    return dp[0][aim];
}
```

**方法3：动态规划优化**

```java
private static int dp2(int[] arr, int aim) {
        if (arr == null || arr.length == 0 || aim < 0) {
            return 0;
        }
        int N = arr.length;
        int[][] dp = new int[N + 1][aim + 1];
        dp[N][0] = 1;
        for (int index = N - 1; index >= 0; index--) {
            for (int rest = 0; rest <= aim; rest++) {
               // int ways = 0;
                // 每一张都是无数的，但是不能大于 rest / arr[index] 张
                // 根据for循环可知，当前位置的数，依赖的是它下面的位置上从左往右的数
//                for (int zhang = 0; zhang * arr[index] <= rest; zhang++) {
//                    ways += dp[index + 1][rest - (zhang * arr[index])];
//                }
                // 故可以知道，当前位置的的数，相当于二维矩阵中当前位置左边的数，和下面的数的和
                dp[index][rest] = dp[index + 1][rest]; // 下面的数
                if (rest - arr[index] >= 0) { // 只有rest比当前位置的数大的时候才又左边的值
                    dp[index][rest] += dp[index][rest - arr[index]]; // 左边的数
                }
            }
        }
        return dp[0][aim];
    }
```

### 题目十三：

arr是货币数组，其中的值都是正数。再给定一个正数aim。
每个值都认为是一张货币，
认为值相同的货币没有任何不同，
返回组成aim的方法数
例如：arr = {1,2,1,1,2,1,2}，aim = 4
方法：1+1+1+1、1+1+2、2+2
一共就3种方法，所以返回3

**方法1：暴力递归**

```java
public static class Info {
    // 面值
    public int[] coins;
    // 对应张数
    public int[] sum;

    public Info(int[] c, int[] s) {
        coins = c;
        sum = s;
    }
}

private static Info getInfo(int[] arr) {
    HashMap<Integer, Integer> counts = new HashMap<>();
    for (int value : arr) {
        if (!counts.containsKey(value)) {
            counts.put(value, 1);
        } else {
            counts.put(value, counts.get(value) + 1);
        }
    }
    int N = counts.size();
    int[] coins = new int[N];
    int[] sum = new int[N];
    int index = 0;
    for (Map.Entry<Integer, Integer> entry : counts.entrySet()) {
        coins[index] = entry.getKey();
        sum[index++] = entry.getValue();
    }
    return new Info(coins, sum);
}

public static int coinsWay(int[] arr, int aim) {
    if (arr == null || arr.length == 0 || aim < 0) {
        return 0;
    }
    Info info = getInfo(arr);
    return process(info.coins, info.sum, 0, aim);
}

private static int process(int[] coins, int[] sum, int index, int rest) {
    if (index == coins.length) {
        return rest == 0 ? 1 : 0;
    }
    int ways = 0;
    // 每一张都是无数的，但是不能大于 rest / arr[index] 张
    for (int zhang = 0; zhang * coins[index] <= rest && zhang <= sum[index]; zhang++) {
        ways += process(coins, sum, index + 1, rest - (zhang * coins[index]));
    }
    return ways;
}
```

**方法2：动态规划**

```java
public static int dp1(int[] arr, int aim) {
    if (arr == null || arr.length == 0 || aim < 0) {
        return 0;
    }
    Info info = getInfo(arr);
    int[] coins = info.coins;
    int[] sums = info.sum;
    int N = coins.length;
    int[][] dp = new int[N + 1][aim + 1];
    dp[N][0] = 1;
    for (int index = N - 1; index >= 0; index--) {
        for (int rest = 0; rest <= aim; rest++) {
            int ways = 0;
            // 每一张是有限的，所以不能大于  coins[index] * 张数 < aim 和当前的张数
            for (int zhang = 0; zhang * coins[index] <= rest && zhang <= sums[index]; zhang++) {
                ways += dp[index + 1][rest - (zhang * coins[index])];
            }
            dp[index][rest] = ways;
        }
    }
    return dp[0][aim];
}
```

**方法3：动态规划优化**

```java
public static int dp2(int[] arr, int aim) {
    if (arr == null || arr.length == 0 || aim < 0) {
        return 0;
    }
    Info info = getInfo(arr);
    int[] coins = info.coins;
    int[] sums = info.sum;
    int N = coins.length;
    int[][] dp = new int[N + 1][aim + 1];
    dp[N][0] = 1;
    for (int index = N - 1; index >= 0; index--) {
        for (int rest = 0; rest <= aim; rest++) {
            // 去掉for循环
            dp[index][rest] = dp[index + 1][rest]; // 下面的数
            if (rest - coins[index] >= 0) { // 只有rest比当前位置的数大的时候才又左边的值
                dp[index][rest] += dp[index][rest - coins[index]]; // 左边的数
            }
            // 要减去满足条件的重复值
            if (rest - coins[index] * (sums[index] + 1) >= 0) {
                dp[index][rest] -= dp[index + 1][rest - coins[index] * (sums[index] + 1)];
            }
        }
    }
    return dp[0][aim];
}
```

### 题目十四：

给定5个参数，N，M，row，col，k
表示在N*M的区域上，醉汉Bob初始在(row,col)位置
Bob一共要迈出k步，且每步都会等概率向上下左右四个方向走一个单位
任何时候Bob只要离开N*M的区域，就直接死亡
返回k步之后，Bob还在N*M的区域的概率

**方法1：暴力递归**

```java
public static double livePosibility1(int row, int col, int k, int N, int M) {
    // 一个点可以有4中方式，所有一共有4的k次方中可能
    return (double) process(row, col, k, N, M) / Math.pow(4, k);
}

private static long process(int row, int col, int rest, int N, int M) {
    if (row < 0 || row == N || col < 0 || col == M) {
        return 0;
    }
    // 还在棋盘中！
    if (rest == 0) {
        return 1;
    }
    // 还在棋盘中！还有步数要走
    long up = process(row - 1, col, rest - 1, N, M);
    long down = process(row + 1, col, rest - 1, N, M);
    long left = process(row, col - 1, rest - 1, N, M);
    long right = process(row, col + 1, rest - 1, N, M);
    return up + down + left + right;
}
```

**方法2：动态规划**

```java
public static double livePosibility2(int row, int col, int k, int N, int M) {
    // 位置，还有步数，三个变量
    long[][][] dp = new long[N][M][k + 1];
    // rest == 0 情况
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < M; j++) {
            dp[i][j][0] = 1;
        }
    }
    for (int rest = 1; rest <= k; rest++) {
        for (int r = 0; r < N; r++) {
            for (int c = 0; c < M; c++) {
                long up = pick(dp, r - 1, c, rest - 1, N, M);
                long down = pick(dp, r + 1, c, rest - 1, N, M);
                long left = pick(dp, r, c - 1, rest - 1, N, M);
                long right = pick(dp, r, c + 1, rest - 1, N, M);
                dp[r][c][rest] = up + down + left + right;
            }
        }
    }
    return (double) dp[row][col][k] / Math.pow(4, k);
}

public static long pick(long[][][] dp, int r, int c, int rest, int N, int M) {
    if (r < 0 || r == N || c < 0 || c == M) {
        return 0;
    }
    return dp[r][c][rest];
}
```

## 怎么尝试一件事？

1）有经验但是没有方法论？

2）怎么判断一个尝试就是最优尝试？

3）难道尝试这件事真的只能拼天赋？那我咋搞定我的面试？

4）动态规划是啥？好高端的样子哦…可是我不会啊！和尝试有什么关系？

最强的私货来了！-> 暴力递归到动态规划的套路！解决任何面试中的动态规划问题！

## 什么暴力递归可以继续优化？

有重复调用同一个子问题的解，这种递归可以优化

如果每一个子问题都是不同的解，无法优化也不用优化

## 暴力递归和动态规划的关系

某一个暴力递归，有解的重复调用，就可以把这个暴力递归优化成动态规划

任何动态规划问题，都一定对应着某一个有重复过程的暴力递归

但不是所有的暴力递归，都一定对应着动态规划

## 面试题和动态规划的关系

解决一个问题，可能有很多尝试方法

可能在很多尝试方法中，又有若干个尝试方法有动态规划的方式

一个问题   可能有   若干种动态规划的解法

## 如何找到某个问题的动态规划方式？

1）设计暴力递归：重要原则+4种常见尝试模型！重点！

2）分析有没有重复解：套路解决

3）用记忆化搜索 -> 用严格表结构实现动态规划：套路解决

4）看看能否继续优化：套路解决

## 面试中设计暴力递归过程的原则

1）每一个可变参数的类型，一定不要比int类型更加复杂

2）原则1）可以违反，让类型突破到一维线性结构，那必须是单一可变参数

3）如果发现原则1）被违反，但不违反原则2），只需要做到记忆化搜索即可

4）可变参数的个数，能少则少

## 知道了面试中设计暴力递归过程的原则，然后呢？

一定要逼自己找到不违反原则情况下的暴力尝试！

如果你找到的暴力尝试，不符合原则，马上舍弃！找新的！

如果某个题目突破了设计原则，一定极难极难，面试中出现概率低于5%！

## 常见的4种尝试模型

1）从左往右的尝试模型

2）范围上的尝试模型

3）多样本位置全对应的尝试模型

4）寻找业务限制的尝试模型

## 如何分析有没有重复解

列出调用过程，可以只列出前几层

有没有重复解，一看便知

## 暴力递归到动态规划的套路

1）你已经有了一个不违反原则的暴力递归，而且的确存在解的重复调用
2）找到哪些参数的变化会影响返回值，对每一个列出变化范围
3）参数间的所有的组合数量，意味着表大小
4）记忆化搜索的方法就是傻缓存，非常容易得到
5）规定好严格表的大小，分析位置的依赖顺序，然后从基础填写到最终解
6）对于有枚举行为的决策过程，进一步优化

## 动态规划的进一步优化

1）空间压缩

2）状态化简

3）四边形不等式

4）其他优化技巧

