## 暴力递归

**暴力递归就是尝试**

1. 把问题转化为规模缩小了的同类问题的子问题
2. 有明确的不需要继续进行递归的条件(base case)
3. 有当得到了子问题的结果之后的决策过程
4. 不记录每一个子问题的解

## 熟悉什么叫尝试？

- 打印n层汉诺塔从最左边移动到最右边的全部过程

- 打印一个字符串的全部子序列

  ```java
  // s -> "abc" ->
  public static List<String> subs(String s) {
      char[] str = s.toCharArray();
      String path = "";
      List<String> ans = new ArrayList<>();
      process1(str, 0, ans, path);
      return ans;
  }
  
  /**
   * str 固定参数
   * 来到了str[index]字符，index是位置
   * str[0..index-1]已经走过了！之前的决定，都在path上
   * 之前的决定已经不能改变了，就是path
   * str[index....]还能决定，之前已经确定，而后面还能自由选择的话，
   * 把所有生成的子序列，放入到ans里去
   */
  private static void process1(char[] str, int index, List<String> ans, String path) {
      if (index == str.length) {
          ans.add(path);
          return;
      }
      // 没要index位置的字符
      process1(str, index + 1, ans, path);
      // 要了index位置的字符
      process1(str, index + 1, ans, path + str[index]);
  }
  ```

- 打印一个字符串的全部子序列，要求不要出现重复字面值的子序列

  ```java
  public static List<String> subsNoRepeat(String s) {
      char[] str = s.toCharArray();
      String path = "";
      HashSet<String> set = new HashSet<>();
      process2(str, 0, set, path);
      return new ArrayList<>(set);
  }
  
  private static void process2(char[] str, int index, HashSet<String> ans, String path) {
      if (index == str.length) {
          ans.add(path);
          return;
      }
      // 没要index位置的字符
      process2(str, index + 1, ans, path);
      // 要了index位置的字符
      process2(str, index + 1, ans, path + str[index]);
  }
  ```

- 打印一个字符串的全部排列

  **方法1：**

  ```java
  public static List<String> permutation1(String s) {
      List<String> ans = new ArrayList<>();
      if (s == null || s.length() == 0) {
          return ans;
      }
      char[] chars = s.toCharArray();
      ArrayList<Character> characters = new ArrayList<>();
      for (char ch : chars) {
          characters.add(ch);
      }
      String path = "";
      func1(characters, ans, path);
      return ans;
  }
  
  // res : abc
  private static void func1(ArrayList<Character> rest, List<String> ans, String path) {
      if (rest.isEmpty()) {
          ans.add(path);
      } else {
          for (int i = 0; i < rest.size(); i++) {
              char cur = rest.get(i);
              // 拿出 a, 看 b，c情况， 到 b，了，拿出 b，然后看 c出情况， -》情况1， a b c 情况2: a, c , b
              rest.remove(i);
              func1(rest, ans, path + cur);
              rest.add(i, cur);
          }
      }
  }
  ```

  **方法2：**

  ```java
  public static List<String> permutation2(String s) {
      List<String> ans = new ArrayList<>();
      if (s == null || s.length() == 0) {
          return ans;
      }
      char[] str = s.toCharArray();
      func2(str, 0, ans);
      return ans;
  }
  
  private static void func2(char[] str, int index, List<String> ans) {
      if (index == str.length) {
          ans.add(String.valueOf(str));
      } else {
          for (int i = index; i < str.length; i++) {
              swap(str, index, i);
              func2(str, index + 1, ans);
              swap(str, index, i);
          }
      }
  }
  
  public static void swap(char[] chs, int i, int j) {
      char tmp = chs[i];
      chs[i] = chs[j];
      chs[j] = tmp;
  }
  ```

- 打印一个字符串的全部排列，要求不要出现重复的排列

  ```java
  public static List<String> permutation3(String s) {
      List<String> ans = new ArrayList<>();
      if (s == null || s.length() == 0) {
          return ans;
      }
      char[] str = s.toCharArray();
      func3(str, 0, ans);
      return ans;
  }
  
  private static void func3(char[] str, int index, List<String> ans) {
      if (index == str.length) {
          ans.add(String.valueOf(str));
      } else {
          boolean[] visited = new boolean[256];
          for (int i = index; i < str.length; i++) {
              // 当前这个位置是否被访问过
              if(!visited[str[i]]){
                  visited[str[i]] = true;
                  swap(str, index, i);
                  func3(str, index + 1, ans);
                  swap(str, index, i);
              }
          }
      }
  }
  ```

## 仰望好的尝试？

给你一个栈，请你逆序这个栈，不能申请额外的数据结构，只能使用递归函数。 如何实现? 

```java
public static void reverse(Stack<Integer> stack) {
    if (stack.isEmpty()) {
        return;
    }
    int i = f(stack);
    reverse(stack);
    stack.push(i);
}

// 栈底元素移除掉
// 上面的元素盖下来
// 返回移除掉的栈底元素
private static int f(Stack<Integer> stack) {
    int result = stack.pop();
    if(stack.isEmpty()){
        return result;
    }else {
        int last  = f(stack);
        stack.push(result);
        return  last;
    }
}
```

### 题目一

假设有排成一行的N个位置，记为1~N，N 一定大于或等于 2
开始时机器人在其中的M位置上(M 一定是 1~N 中的一个)
如果机器人来到1位置，那么下一步只能往右来到2位置；
如果机器人来到N位置，那么下一步只能往左来到 N-1 位置；
如果机器人来到中间位置，那么下一步可以往左走或者往右走；
规定机器人必须走 K 步，最终能来到P位置(P也是1~N中的一个)的方法有多少种
给定四个参数 N、M、K、P，返回方法数。 

**方法1：暴力递归**

```java
public static int ways1(int N, int start, int aim, int K) {
    if (N < 2 || start < 1 || start > N || aim < 1 || aim > N || K < 1) {
            return -1;
     }
    return process1(start, K, aim, N);
}

// 机器人当前来到的位置是cur，
// 机器人还有rest步需要走
// 最终目标aim
// 有哪些位置 1~ N
// 返回：机器人从cur出发，走过rest步之后，最终停在aim的方法数，是多少？
private static int process1(int cur, int rest, int aim, int N) {
    if (rest == 0) { // 如果已经不需要走了，走完了！
        return cur == aim ? 1 : 0;
    }
    if (cur == 1) {
        return process1(2, rest - 1, aim, N);
    }
    if (cur == N) {
        return process1(N - 1, rest - 1, aim, N);
    }
    // cur - 1往左， cur + 1 往右走一步
    return process1(cur - 1, rest - 1, aim, N) + process1(cur + 1, rest - 1, aim, N);
}
```

**方法2：暴力递归到动态规划**

```java
public static int ways2(int N, int start, int aim, int K) {
    if (N < 2 || start < 1 || start > N || aim < 1 || aim > N || K < 1) {
            return -1;
     }
    int[][] dp = new int[N + 1][K + 1];
    for (int i = 0; i <= N; i++) {
        for (int j = 0; j <= K; j++) {
            dp[i][j] = -1;
        }
    }
    return process2(start, K, aim, N, dp);
}

private static int process2(int cur, int rest, int aim, int N, int[][] dp) {
    if (dp[cur][rest] != -1) {
        return dp[cur][rest];
    }
    int ans = 0;
    if (rest == 0) { // 如果已经不需要走了，走完了！
        ans = cur == aim ? 1 : 0;
    } else if (cur == 1) {
        ans = process1(2, rest - 1, aim, N);
    } else if (cur == N) {
        ans = process1(N - 1, rest - 1, aim, N);
    } else {
        // cur - 1往左， cur + 1 往右走一步
        ans = process1(cur - 1, rest - 1, aim, N) + process1(cur + 1, rest - 1, aim, N);
    }
    dp[cur][rest] = ans;
    return ans;
}
```

**方法3：动态规划**

```java
// 分析：
// 根据递归中条件进行分析：
public static int ways3(int N, int start, int aim, int K) {
    if (N < 2 || start < 1 || start > N || aim < 1 || aim > N || K < 1) {
            return -1;
     }
    int[][] dp = new int[N + 1][K + 1];
    // 根据递归中条件进行分析：
    // 1. rest = 0, cur = aim : 1 说明终点这个位置为1
    dp[aim][0] = 1;
    // 第一列中aim行的第一个树数已赋值
    for (int rest = 1; rest <= K; rest++) {
        // 2. cur == 1;
        dp[1][rest] = dp[2][rest - 1];
        // 4. else
        for (int cur = 2; cur < N; cur++) {
            dp[cur][rest] = dp[cur - 1][rest - 1] + dp[cur + 1][rest - 1];
        }
        // 3. cur == N
        dp[N][rest] = dp[N - 1][rest - 1];
    }
    return dp[start][K];
}
```

### **题目二：**

给定一个整型数组arr，代表数值不同的纸牌排成一条线
玩家A和玩家B依次拿走每张纸牌
规定玩家A先拿，玩家B后拿
但是每个玩家每次只能拿走最左或最右的纸牌
玩家A和玩家B都绝顶聪明
请返回最后获胜者的分数。

**方法1：暴力递归**

```java
public static int win1(int[] arr) {
    int first = f1(arr, 0, arr.length - 1);
    int second = g1(arr, 0, arr.length - 1);
    return Math.max(first, second);
}

// arr[L..R]，先手获得的最好分数返回
public static int f1(int[] arr, int L, int R) {
    if (L == R) {
        return arr[L];
    }
    int p1 = arr[L] + g1(arr, L + 1, R); // 拿走了L位置的数
    int p2 = arr[R] + g1(arr, L, R - 1); // 拿走了R位置的数
    return Math.max(p1, p2);
}

// arr[L..R]，后手获得的最好分数返回
public static int g1(int[] arr, int L, int R) {
    if (L == R) {
        return 0;
    }
    int p1 = f1(arr, L + 1, R);  // 对手拿走了L位置的数
    int p2 = f1(arr, L, R - 1); // 对手拿走了R位置的数
    return Math.min(p1, p2);
}
```

**方法2：暴力递归到动态规划**

```java
public static int win2(int[] arr) {
    int N = arr.length;
    int[][] fmap = new int[N][N];
    int[][] gmap = new int[N][N];
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            fmap[i][j] = -1;
            gmap[i][j] = -1;
        }
    }
    int first = f2(arr, 0, arr.length - 1, fmap, gmap);
    int second = g2(arr, 0, arr.length - 1, fmap, gmap);
    return Math.max(first, second);
}

// arr[L..R]，先手获得的最好分数返回
public static int f2(int[] arr, int L, int R, int[][] fmap, int[][] gmap) {
    if (fmap[L][R] != -1) {
        return fmap[L][R];
    }
    int ans = 0;
    if (L == R) {
        ans = arr[L];
    } else {
        int p1 = arr[L] + g2(arr, L + 1, R, fmap, gmap); // 拿走了L位置的数
        int p2 = arr[R] + g2(arr, L, R - 1, fmap, gmap); // 拿走了R位置的数
        ans = Math.max(p1, p2);
    }
    fmap[L][R] = ans;
    return ans;
}

// arr[L..R]，后手获得的最好分数返回
public static int g2(int[] arr, int L, int R, int[][] fmap, int[][] gmap) {
    if (gmap[L][R] != -1) {
        return gmap[L][R];
    }
    int ans = 0;
    if (L != R) {
        int p1 = f2(arr, L + 1, R, fmap, gmap);  // 对手拿走了L位置的数
        int p2 = f2(arr, L, R - 1, fmap, gmap); // 对手拿走了R位置的数
        ans = Math.min(p1, p2);
    }
    gmap[L][R] = ans;
    return ans;
}
```

**方法3：动态规划**

```java
public static int win3(int[] arr) {
    if (arr == null || arr.length == 0) {
        return 0;
    }
    int N = arr.length;
    int[][] fmap = new int[N][N];
    int[][] gmap = new int[N][N];
    // 对角线
    for (int i = 0; i < N; i++) {
        fmap[i][i] = arr[i];
    }
    for (int startCol = 1; startCol < N; startCol++) {
        int L = 0;
        int R = startCol;
        // 防止越界
        while (R < N) {
            fmap[L][R] = Math.max(arr[L] + gmap[L + 1][R], arr[R] + gmap[L][R - 1]);
            gmap[L][R] = Math.min(fmap[L + 1][R], fmap[L][R - 1]);
            L++;
            R++;
        }
    }
    return Math.max(fmap[0][N - 1], gmap[0][N - 1]);
}
```

## 怎么尝试一件事？

1）有经验但是没有方法论？

2）怎么判断一个尝试就是最优尝试？

3）难道尝试这件事真的只能拼天赋？那我咋搞定我的面试？

4）动态规划是啥？好高端的样子哦…可是我不会啊！和尝试有什么关系？

最强的私货来了！-> 暴力递归到动态规划的套路！解决任何面试中的动态规划问题！

## 什么暴力递归可以继续优化？

有重复调用同一个子问题的解，这种递归可以优化

如果每一个子问题都是不同的解，无法优化也不用优化

## 暴力递归和动态规划的关系

某一个暴力递归，有解的重复调用，就可以把这个暴力递归优化成动态规划

任何动态规划问题，都一定对应着某一个有重复过程的暴力递归

但不是所有的暴力递归，都一定对应着动态规划

## 面试题和动态规划的关系

解决一个问题，可能有很多尝试方法

可能在很多尝试方法中，又有若干个尝试方法有动态规划的方式

一个问题   可能有   若干种动态规划的解法

## 如何找到某个问题的动态规划方式？

1）设计暴力递归：重要原则+4种常见尝试模型！重点！

2）分析有没有重复解：套路解决

3）用记忆化搜索 -> 用严格表结构实现动态规划：套路解决

4）看看能否继续优化：套路解决

## 面试中设计暴力递归过程的原则

1）每一个可变参数的类型，一定不要比int类型更加复杂

2）原则1）可以违反，让类型突破到一维线性结构，那必须是单一可变参数

3）如果发现原则1）被违反，但不违反原则2），只需要做到记忆化搜索即可

4）可变参数的个数，能少则少

## 知道了面试中设计暴力递归过程的原则，然后呢？

一定要逼自己找到不违反原则情况下的暴力尝试！

如果你找到的暴力尝试，不符合原则，马上舍弃！找新的！

如果某个题目突破了设计原则，一定极难极难，面试中出现概率低于5%！

## 常见的4种尝试模型

1）从左往右的尝试模型

2）范围上的尝试模型

3）多样本位置全对应的尝试模型

4）寻找业务限制的尝试模型

## 如何分析有没有重复解

列出调用过程，可以只列出前几层

有没有重复解，一看便知

## 暴力递归到动态规划的套路

1）你已经有了一个不违反原则的暴力递归，而且的确存在解的重复调用
2）找到哪些参数的变化会影响返回值，对每一个列出变化范围
3）参数间的所有的组合数量，意味着表大小
4）记忆化搜索的方法就是傻缓存，非常容易得到
5）规定好严格表的大小，分析位置的依赖顺序，然后从基础填写到最终解
6）对于有枚举行为的决策过程，进一步优化

## 动态规划的进一步优化

1）空间压缩

2）状态化简

3）四边形不等式

4）其他优化技巧

