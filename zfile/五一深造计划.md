# 五一深造计划















### 僵尸进程

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <assert.h>
#include <sys/types.h>

int main() {
        pid_t pid = fork();

        if (0 == pid) {
                printf("child id is %d\n", getpid());
                printf("parent id is %d\n", getppid());
        } else {
                while(1) {}
        }
}
```

### 孤儿进程

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <assert.h>
#include <sys/types.h>

int main() {
        pid_t pid = fork();

        if (0 == pid) {
                printf("child ppid is %d\n", getppid());
                sleep(10);
                printf("parent ppid is %d\n", getppid());
        } else {
                printf("parent id is %d\n", getpid());
                sleep(5);
                exit(0);
        }
}

```

### 进程调度

内核kernel2.6之后都采用CFS调度策略：Completely Fair Scheduler

按优先级分配时间片的比例，记录每个进程的执行时间，如果有一个进程执行时间不到它应该分配的比例，则优先执行

默认调度策略：

实时（急诊）优先级分高低 对应是FIFO(First In First Out)是指优先级越高越先执行，该优先级可以分为0-99个优先级，主要指的是一些内核线程之类的，如果优先级一样，则使用RR-（Round Robin）轮询策略。

普通：CFS，多指的是一些用户线程。

# 中断

硬件跟操作系统内核打交道的一种机制，主要有硬件中断，比如（键盘输入，网卡，内存等）和软中断（著名的0x80中断），调用中断之后，系统程序才知道你需要干什么？

系统调用：可以使用0x80或者sysenter原语（最底层硬件的中断）

汇编中（基本就5中寄存器）通过ax寄存器填入调用号，参数通过bx，cx，dx，si，di传入内核，返回值是通过ax返回。

典型的场景：

java都网络 -> jvm read() -> C 库read() -> 内核空间 -> sys_call()(系统调用处理程序) -> sys_read();

## 从汇编角度理解软中断

### 搭建汇编环境

apt-get install nasm

```assembly
;hello.asm
;write(int fd, const void *buffer, size_t nbytes)
;fd 文件描述符 file descriptor - linux下一切皆文件

section data
    msg db "Hello", 0xA
    len equ $ - msg

section .text
global _start
_start:

    mov edx, len
    mov ecx, msg
    mov ebx, 1 ;文件描述符1 std_out
    mov eax, 4 ;write函数系统调用号 4
    int 0x80

    mov ebx, 0
    mov eax, 1 ;exit函数系统调用号
    int 0x80
```

编译：nasm -f elf hello.asm -o hello.o

链接:ld -m elf_i386 -o hello hello.o(链接时为了找到程序运行的环境)

一个程序的执行过程，要么处于用户态，要么处于内核态

# 内存管理

## 内存管理的发展历程

DOS时代 - 同一时间只能有一个进程在运行（也有一些特殊算法可以支持多进程）

windows9x - 多个进程装入内存 1：内存不够用 2：互相打扰

为了解决这两个问题，诞生了现在的内存管理系统：虚拟地址 分页装入 软硬件结合寻址

1. 分页（内存不够用），内存中分为固定大小的页框（默认4k），把程序（硬盘上）分成4K大小的块，用到那块，加载那块，加载过程中，如果内存已经满了，会把最不常用的一块放入到swap分区，把最新的一块加载进来，这就是著名的LRU算法。
   1. LRU算法 
   2. Least Recently Uesed
   3. 可以hash表，（保证查找操作O(1),+链表(b=保证排序操作和新增操作O(1))）
   4. 最后的解决方案是hash表 + 双线链表，使得增加，查找，移动数据的时间复杂度都是O(1)。
2. 虚拟内存（解决互相打扰问题）
   1. 为了保证互不影响-让进程工作再虚拟空间，程序中用到的空间地址不在是直接的物理地址，而是虚拟的地址，这样，A进程永远不可能访问到进程B的内存空间
   2. 虚拟空间多大？寻址空间 - 64位系统 2^64，比物理空间大很多，单位是byte
   3. 站再虚拟的角度，进程是个独享整个系统 + CPU
   4. 内存映射：偏移量 + 段的基地址 = 线性地址（虚拟空间）
   5. 线性地址通过OS + MMU（硬件Memory Management Unit）
3. 缺页中断
   1. 穿用到的页面内存中没有，产生缺页异常（中断），由内核处理并加载

# ZGC

算法叫做：Colored Pointer

![zgc原理](../images/jvm/gc/zgc原理.png)

GC信息记录在指针上，不是记录在头部， immediate memory use这样该空间就可以立即使用。

42位指针 寻址空间4T JDK13 -> 16T 目前为止最大16T 2^44，因为总线的地址就只有48位

CPU如何区分一个立即数和一条指令的？根据总线来区分的

总线内部分为：数据总线 地址总线 控制总线

地址总线目前：48位

颜色指针本质上包含了地址映射的概念。