# 

## 程序员必读书籍

- 《编码：隐匿在计算机软硬件背后的语言》
- 《深入理解计算机系统》
- 语言《C程序设计语言》《C Primer Plus》
- 数据结构与算法：leetCode
- 《Java数据结构与算法》《算法》
- 《算法导论》《计算机程序设计艺术》//难
- 操作系统：*Linux内核源码解析*  Linux内核设计与实现 30天自制操作系统
- 网络：机工《TCP/IP详解》卷一
- 编译原理：机工 龙书 《编译原理》 《编程语言实现模式》马语
- 数据库：SQLite源码 Derby - JDK自带数据库

## 缓存行测试

CPU  多级缓存

![workModeForTwoCache](../images/基础/workModeForTwoCache.png)



什么是缓存行？

缓存行：即CacheLine

**操作系统的内存有如下：CPU 有三级缓存，依次 L1 L2 L3 ，最后是主内存 ，越接近CPU的速度越快,则L1速度>L2>L3>主内存**

*CPU缓存(Cache)有很多缓存行(cache line)组成,一个缓存行占64个字节。Java的long类型是8个字节，则一个缓存行能容纳8个long类型的数据。CPU从主内存拉取数据的时候，相邻的数据，会优先放入同一个缓存行中。Long数组的其中一个数据，则其他7个也会被放在同一个缓存行中。当然，读取同一个缓存行的数据，效率非常高。*

![多级缓存](../images/基础/多级缓存.png)

缓存行越大，局部性空间效率越高，但读取时间慢

缓存行越小，局部性空间效率越低，但读取时间快

取一个折中值，目前多用：64字节



```java
public class T03_CacheLinePadding {
    public static volatile long[] arr = new long[2];
    public static void main(String[] args) throws Exception {
        Thread t1 = new Thread(()->{
            for (long i = 0; i < 1_000_000_000L; i++) {
                arr[0] = i;
            }
        });
        Thread t2 = new Thread(()->{
            for (long i = 0; i < 1_000_000_000L; i++) {
                arr[1] = i;
            }
        });
        final long start = System.nanoTime();
        t1.start();
        t2.start();
        t1.join();
        t2.join();
        System.out.println((System.nanoTime() - start)/100_0000);
    }
    //结果大概4711
}
```

```java
public class T04_CacheLinePadding {

    public static volatile long[] arr = new long[16];
    public static void main(String[] args) throws Exception {
        Thread t1 = new Thread(()->{
            for (long i = 0; i < 1_000_000_000L; i++) {
                arr[0] = i;
            }
        });

        Thread t2 = new Thread(()->{
            for (long i = 0; i < 1_000_000_000L; i++) {
                arr[8] = i;
            }
        });

        final long start = System.nanoTime();
        t1.start();
        t2.start();
        t1.join();
        t2.join();
        System.out.println((System.nanoTime() - start)/100_0000);
    }
    //结果大概3382
}
```

缓存行对齐：对有些特别敏感的数据，会存在线程高竞争的访问，为了保证不发生伪共享，可以使用缓存行对齐的编程方式

### 伪共享

通常提到缓存行，大多数文章都会提到伪共享问题（正如提到 CAS 便会提到 ABA 问题一般）。

伪共享指的是多个线程同时读写同一个缓存行的不同变量时导致的CPU缓存失效。尽管这些变量之间没有任何关系，但由于在主内存中临近，存在与同一个缓存行之中，他们的互相覆盖会导致频繁的缓存未名中，引发性能下降，伪共享问题难以定位，如果系统设计者不理解CPU缓存架构，甚至永远无法发现 - 原来我的程序可以更快。![伪共享](../images/基础/伪共享.png)

正如图中所述，如果多个线程的变量共享了同一个 CacheLine，任意一方的修改操作都会使得整个 CacheLine 失效（因为 CacheLine 是 CPU 缓存的最小单位），也就意味着，频繁的多线程操作，CPU 缓存将会彻底失效，降级为 CPU core 和主内存的直接交互。

**伪共享问题的解决方法便是字节填充。**

![伪共享-字节填充](../images/基础/伪共享-字节填充.png)

JDK7中，很多采用long padding提高效率

JDK8中加入了@Contended注解

```java
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.FIELD, ElementType.TYPE})
public @interface Contended {
    String value() default "";
}
```

并且需要同时开启JVM参数 -XX:-RestrictContended



### 禁止乱序

原子指令，如X86上的“lock”

JVM内存屏障：

LoadLoad屏障：

​	对于这样的语句Load1；LoadLoad; Load2;

### volatile的实现细节

JVM层面：

具体还是lock指令。

StoreStoreBarrier		   LoadLoadBarrier

volatile 写操作			  volatile 读操作

StoreLoadBarrier			LoadStoreBarrier

//修饰对象，有可能是将这个对象有读写改情况。

### hanppens before 

具有8个原则：



### as if serial （看上去像顺序执行）

不管硬件什么顺序，单线程的结果不变，看上去像是serial。

### NUMA：

Non Uniform Memory Access

ZGC：- NUMA aware

分配内存会优先分配该下该线程所在CPU的最近内存

# OS

## 内核分类

微内核 - 弹性部署 5G IoT

宏内核 - PC phone

外核 - 科研 实验中 为应用定制操作系统 (多租户 request-based GC JVM)

## 用户态与内核态

cpu分不同的指令级别

linux内核跑在ring 0级， 用户程序跑在ring 3，对于系统的关键访问，需要经过kernel的同意，保证系统健壮性

内核执行的操作 - > 200多个系统调用 sendfile read write pthread fork 

JVM -> 站在OS老大的角度，就是个普通程序

# 进程 线程 纤程 中断

面试高频：进程和线程有什么区别？

答案：进程就是一个程序运行起来的状态，线程是一个进程中的不同的执行路径。**专业：进程是OS分配资源的基本单位，线程是执行调度的基本单位。**分配资源最重要的是：独立的内存空间，线程调度执行（线程共享进程的内存空间，没有自己独立的内存空间）g

纤程：Fiber 线程中的线程，多个线程对应一个纤程。

优势：

	1. 占有资源很少。操作系统起一个线程需要1M空间，Fiber大概需要4Kb内存，
 	2. 切换简单
 	3. 可以启动很多个10W+

目前2020 3.22支持内置纤程的语言：Kotlin Scala Go Python(lib) Java(Loom纤程)

具体怎么实现的？

跟操作系统的实现类似。内部

### 纤程的 应用场景

纤程 VS 线程池：很短的计算任务，不需要和内存打交到，