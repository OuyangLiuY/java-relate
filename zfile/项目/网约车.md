# 网约车

**背景：**车载系统，能控制车机，车可以做定制，车上有屏幕，可供娱乐（可定制）

**为什么做：**残障人事，有轮椅，孕妇（派遣公司比较稳的），小孩（儿童座椅），给特定人群提供不同的

**计划阶段：**进度安排，资源计划，成本评估，质量保证计划，风险，实施。

**面试：**项目做不完？（加班，加人，功能排优先级，重要的先做做保证能用）
实施控制：

**工作职责：**

**组长：**接口定义，工程结构设计，代码review，各方沟通（产品，测试），核心功能开发

**kickoff：**各方参与，齐聚一堂，启动会，动员大会

**微服务设计原则：** **隔离系统的变化点**

**具体原则：**
高内聚，低耦合。
高度自治： 开发
以业务为中心
弹性设计：（容错，隔离，降级）
自动化，持续集成，持续交付
粒度把控：没有标准，任何一个服务，不要因为自己的开发和维护， 影响其他服务

**AKF：**
x轴：复制备份
y轴：业务拆分
z轴：数据分区

## 需求：

**乘客端:**

​	1、发送验证码

​	2、登录/注册

​	3、查看开通区域

​	4、预估价格

​	5、下单

​	6、（司机流程）

​	7、支付（分布式事务：订单，支付，积分）

​	8、评价

**司机端：**

​	1、发送验证码

​	2、登录、注册

​	3、查看，改变司机状态。

​	4、司机抢单（分布式锁）

​	5、订单状态变更

​	6、发起收款

**boos端：**

运营，维护一些基本数据。

所有服务

![](..\..\images\taxi-online\tax-online-all.jpg)

## 接口设计：

使用TCP/IP(HTTP)协议

**接口安全：**

1、CIA：保密性，完整性，可用性（手机号/身份证脱敏）

2、数据层面，防止SQL注入，过滤框架jsoup

3、xss: 攻击，问题：**用户数据没有过滤，转义**

4、csrf：人机交互，token，解决。问题：**冒充别人登录信息，没有防范不信任的调用。**

5、数据权限控制

6、接口幂等：接口数据多次提交都要保证数据一致

**业务层：**

| 模块     | 项目名                                           | 描述     |
| -------- | ------------------------------------------------ | -------- |
| 乘客端   | api-passenger(订单bean。@RequestBody 订单的bean) | 乘客端   |
| 司机端   | api-driver                                       | 司机端   |
| 司机听单 | api-listen-order                                 | 司机听单 |

**能力层：**

## 

| 模块         | 项目名                                           |
| ------------ | ------------------------------------------------ |
| app升级      | service-app-update                               |
| 订单         | service-order(订单bean。@RequestBody 订单的bean) |
| 派单         | service-order-dispatch                           |
| 乘客用户管理 | service-passenger-user                           |
| 短信         | service-sms                                      |
| 计价         | service-valuation                                |
| 验证码       | service-verification-code                        |
| 钱包         | service-wallet                                   |
| 支付         | service-payment                                  |
| 地图         | service-map                                      |

**第三方：**

短信服务（腾讯，阿里短信，华为短信）

语言服务：隐私号（乘客和司机订单匹配后，A，B，X），录音。

文件服务oss：

地图：高德

消息推送：极光，透传，通知。

支付：微信，支付宝。

航旅纵横：查航班

发票：百望云

前端：vue，android，ios。

**体高QPS的方法:**

两个方向：

​	**提高并发数：**

​	1、使用多线程

​	2、增加各种连接数，入mysql，redis，tomcat

​	3、服务无状态，便于横向扩展（扩机器）

​	**减少响应时间：**

​	1、异步（最终一致性）

​	2、缓存（减少磁盘IO，读多写少）

​	3、数据库优化

​	4、多数据，分批次返回

​	5、减少网络IO

​	6、实时数据对接使用长连接（但会减少并发数）

## 灰度发布：



面试：

项目经验：

个人职责：负责灰度发布的架构方案设计和落地，并且负责核心代码的编写，实现了网关和服务，服务和服务之间的灰度发布。

问题：怎么做的？

1.解决的问题是什么？为什么用灰度发布：（实验新功能，a，b test，小改动的服务不用熬夜（尽量减少用户使用的时延），便于小步快跑。

2、怎么解决的？

3、为什么要这么解决（蓝绿发布，滚动发布，灰度发布）

4、给公司带来的好处？（节省服务器，节省了时延，试错成本）



## 网关：

生产中遇到的问题：

1. token不向后传，（单体项目 -> 微服务 )
2. 老项目/老功能改造中，路由问题，原来url不变，通过网关去适应
3. 动态路由，根据不同用户，对应不同服务

**网关可以做的事情：**

1. 分发服务
2. 身份认证（鉴权）
3. 过滤请求
4. 监控
5. 路由（动态）
6. 限流

## 事务：

### CAP：

一个分布式系统中最多只能同事满足一致性（consistency）、可用性（Availability）和分区容忍性（partition tolerance）这三项中的两项。

它可以作为我们架构设计、技术选型的考量标准。对于大多数互联网应用的场景，节点众多，部署分散，而且现在的集群规模越来越大，所以节点故障，网络故障是常态，而且要保证服务可用性达到N个9（99.99%），并要达到良好的响应性能来提高用户体验。

一般会做出如下选择：**保证P和A，舍弃C强一致性，保证最终一致性。**

### BASE：

BASE是Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）三个词的缩写，BASE理论是对CAP中AP的一个扩展，通过牺牲强一致性来获得可用性，当出现故障允许部分不可用但要保证核心功能可用，允许数据再一段时间内不一致，但最终达到一致状态，满足BASE理论的，我们称之为**柔性事务**

**基本可用：**

分布式系统再出现故障时，允许损失部分可用功能，保证和兴功能可用。如电商项目中交易付款出现故障时，商品依然可以正常浏览。

**软状态：**

由于不要求强一致性，所以BASE允许系统中存在中间状态（也叫软状态），这个状态不影响可用性，如订单中`支付中`、`数据同步中`等状态，等待数据最终一致后将状态改成`成功`状态。

**最终一致性：**

最终一致时指再经过一段时间后，所有系欸但数据都将会达到一致。如订单的`支付中`状态，最终会变成`支付成功`或者`支付失败`，使订单状态与实际交易结果达成一致，但需要一定时间的延迟，等待。

## 单机事务：

单机事务通过数据事务保证，数据库Mysql事务

事务的四个属性：ACID

通过预写式日志，undo log保证原子性，redo log保证持久性，设置隔离级别，保证并发事务进行的时候，保证数据一致性。

引入redo log实现持久性，这个时候就在考虑如果只需要将日志写入磁盘，将数据缓存在内存中，一定时间后再进行更新。

1.原子性(Automic)：一个动作要么做完，要么不做。

2.一致性(Consistency)：保证数据处于一致性的状态，我理解就是保证数据有意义的。

3.隔离性(Isolation)：多个事务并行的结果，应该和多个事务串行的结果一致。

4.持久性(Duration)：一个事务一旦成功提交，对数据改变是永久性的。

其实这个四个属性中，最重要的是一致性，也就是说其他的三个属性都是为了保证一致性而存在。

**原子性如何保证？**

这个就需要说到Mysql的log，Mysql有许多种类的log，例如：二进制日志(binlog)，错误日志，慢查询日志等等。这里需要引入的是undo log。这是Mysql的Write-Ahead-Logging机制。

## 分布式事务：

使用柔性事务保证

### 2pc：两阶段提交

为什么引入2pc？因为每个服务无法感知其他服务的事务状况，需要协调者

![](..\..\images\taxi-online\2pc.jpg)

### 3pc：三阶段提交

减少了资源锁定的时间。

相对于2pc，3pc主要解决单点故障问题，减少阻塞。

区别：

1. 引入超时机制，同时再协调者（超时，中断事务）和参与者中都引入超时机制。
2. 再第一阶段和第二阶段中插入下一个准备阶段。保证了最后提交阶段之前各参与节点的状态是一致的。

![](..\..\images\taxi-online\3pc.jpg)

### 消息队列+定时任务+本地事件表实现：

准备：mq，支付流水表，订单表

1. 调用支付的第三方系统，更细记录为支付中，
2. 支付成功，插入支付系统的事件表中支付成功记录，
3. 异步发送消息给MQ，支付成功/失败消息
4. 定时任务，查询到事件表中new的状态，更新事件表中状态为已发送。
5. 订单系系统中消费到当前发送过来的消息，插入到订单系统的事件表中，并修改记录为已接受。
6. 定时任务，查询到事件表中状态，执行本地业务，修改事件表中状态。

**注意：**不适用于数据量特别大得场景

![](..\..\images\taxi-online\taxi-mq-mysql.jpg)

### LCN：

L：lock，C：confirm，N：notice

LCN官网：

```http
https://www.codingapi.com/docs/txlcn-principle-control/
```

**服务之间关系：**

![](..\..\images\taxi-online\lcn-1.jpg)

**lcn原理图：**

![](..\..\images\taxi-online\lcn-2.jpg)

### TCC：

### LCN+TCC+Redis：

### TCC+Mysql+Redis：

### Seata：

官网文档:

https://seata.io/zh-cn/docs/overview/what-is-seata.html

AT模式：

## 前提

- 基于支持本地 ACID 事务的关系型数据库。
- Java 应用，通过 JDBC 访问数据库。

## 整体机制

两阶段提交协议的演变：

- 一阶段：业务数据和回滚日志记录在同一个本地事务中提交，释放本地锁和连接资源。
- 二阶段：
  - 提交异步化，非常快速地完成。
  - 回滚通过一阶段的回滚日志进行反向补偿。

### 写隔离

- 一阶段本地事务提交前，需要确保先拿到 **全局锁** 。
- 拿不到 **全局锁** ，不能提交本地事务。
- 拿 **全局锁** 的尝试被限制在一定范围内，超出范围将放弃，并回滚本地事务，释放本地锁。

### 读隔离

在数据库本地事务隔离级别 **读已提交（Read Committed）** 或以上的基础上，Seata（AT 模式）的默认全局隔离级别是 **读未提交（Read Uncommitted）** 。

如果应用在特定场景下，必需要求全局的 **读已提交** ，目前 Seata 的方式是通过 SELECT FOR UPDATE 语句的代理。

TCC模式：

SAGA模式:

XA模式:

项目中有用到的分布式事务：

下单，支付，叫车，接单，充值。

### TCC中异常情况：

1、空回滚

try，未执行，cancel执行。比如: try调用超时。

解决方案：加事务控制表

```sql
{
tx_id(全局事务id)
branch_id(分支id)
state(状态，try执行成功/失败得标记)
}
```



2、幂等

多次执行，cancel，confirm

解决方案：加事务控制表

```sql
{
tx_id(全局事务id)
branch_id(分支id)
state(状态，事务初始化，已提交，已回滚等)
}
```



3、悬挂

cancel再try之前执行

try执行超时，结果开始执行cancel，此时try继续执行

解决方案：加事务控制表

cancel得时候，新增一条记录，（如果原来没有记录，执行空方法，再插入回滚记录，try执行得时候，发现有记录，空try

```sql
{
tx_id(全局事务id)
branch_id(分支id)
state(状态，事务初始化，已提交，已回滚等)
}
```

## 可靠消息服务

可靠消息得最终一致性方案：



![](..\..\images\taxi-online\image_car.png)

## 事务消息

分布式系统中的事务，可以使用TCC（Try，confirm，Cancel),2pc来解决分布式系统中的消费原子性

RocketMQ 4.3+提供分布式事务功能，通过RocketMQ事务消息能达到分布式事务的最终一致

![](..\..\images\taxi-online\事务消息.png)

## 分布式事务总结：

2pc（协调者超时回滚，并且占用连接）

3pc（2pc得第一阶段拆成了2个阶段，协调者和参与者都超时，pre超时是回滚，do超时时时提交）

tcc（2pc得第二阶段 拆成了2个阶段，不占用连接，性能高，但是麻烦）（业务简单可以使用）

lcn（实现lcn，tcc）

seata（实现 at，tcc）

消息队列 + 本地事件表

最大努力通知

可靠消息服务

消息事务

Scott Young频道
